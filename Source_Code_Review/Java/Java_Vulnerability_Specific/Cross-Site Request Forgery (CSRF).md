## **1. Introduction to Cross-Site Request Forgery (CSRF)**

**Cross-Site Request Forgery (CSRF)** is a security vulnerability that allows an attacker to trick a victim into submitting unintended requests to a web application in which they are currently authenticated. This can result in unauthorized actions such as changing account details, making transactions, or altering data.

**Key characteristics of CSRF attacks:**

- **Exploits Trust:** The web application trusts the user's browser, so it accepts requests without verifying the intent.
- **Requires User Interaction:** The attacker must convince the user to perform an action (e.g., clicking a link, loading an image).
- **Relies on Session State:** The attack leverages the user's authenticated session with the application.

**Consequences of CSRF include:**

- **Unauthorized Actions:** Changing passwords, transferring funds, or modifying data without the user's consent.
- **Privilege Escalation:** Performing actions with the victim's privileges.
- **Data Corruption:** Unintended or malicious changes to data.

Identifying and mitigating CSRF vulnerabilities is critical to ensure that actions performed on behalf of a user are intended and authorized.

---

<a name="vulnerable-patterns"></a>
## **2. Common Vulnerable Patterns in Java**

Vulnerable patterns in Java applications that can lead to CSRF include:

- **Lack of CSRF Tokens:** Not implementing anti-CSRF tokens in forms or state-changing requests.
- **State-Changing GET Requests:** Using HTTP GET for actions that change state on the server.
- **Missing SameSite Attributes:** Not setting the `SameSite` attribute on cookies.
- **Using Cookies for Authentication Without Additional Checks:** Relying solely on session cookies for authentication without verifying request origin.
- **Inadequate Validation of Request Origin:** Not checking the `Referer` or `Origin` headers.
- **Session Fixation Vulnerabilities:** Allowing attackers to hijack user sessions.
- **Allowing Cross-Origin Requests:** Misconfigured CORS policies that permit cross-origin requests without proper validation.

---

<a name="regex-patterns"></a>
## **3. Regex Patterns for Detection**

Since you have no access to automated tools, you can use the following regex patterns in your IDE's global search functionality to manually search the codebase for potential CSRF vulnerabilities.

### **3.1. Forms Without CSRF Tokens**

**Pattern:**

```regex
<form\s+[^>]*action=["'][^"']*["'][^>]*>
```

**Explanation:**

- Finds form elements in JSP or HTML files.
- Look for forms that do not include CSRF tokens in their fields.

### **3.2. State-Changing GET Requests**

**Pattern:**

```regex
@RequestMapping\s*\(\s*value\s*=\s*["'][^"']*["']\s*(,\s*method\s*=\s*RequestMethod\.GET)?\s*\)
```

**Explanation:**

- Identifies controller methods mapped to URLs, potentially using GET requests.
- Focus on methods that perform state-changing actions.

### **3.3. Missing CSRF Protection Configuration**

**Pattern:**

```regex
http\.csrf\(\)\.disable\(\)
```

**Explanation:**

- Detects code in Spring Security configuration that disables CSRF protection.

### **3.4. Session Cookies Without `HttpOnly` or `Secure` Flags**

Since session cookie configurations are often in configuration files, manually inspect the cookie settings.

**Pattern:**

In `web.xml` or configuration classes, look for:

```xml
<cookie-config>
    <!-- Missing http-only or secure attributes -->
</cookie-config>
```

Or in code:

```java
Cookie cookie = new Cookie("SESSIONID", sessionId);
```

- Check if `cookie.setHttpOnly(true);` and `cookie.setSecure(true);` are missing.

### **3.5. Absence of CSRF Tokens in JSP Pages**

**Pattern:**

```regex
<%@\s+taglib\s+[^%]*%>.*<form\s+[^>]*>
```

**Explanation:**

- Finds JSP pages with forms.
- Look for the absence of CSRF token inclusion using `<input type="hidden" name="_csrf" value="${_csrf.token}"/>`.

### **3.6. Inadequate CORS Configuration**

**Pattern:**

```java
@CrossOrigin\(([^)]*)\)
```

**Explanation:**

- Identifies methods or classes with `@CrossOrigin` annotation.
- Review the configuration to ensure it's not overly permissive (e.g., `origins = "*"`, `allowCredentials = "true"`).

### **3.7. Using `sendRedirect()` Without Validations**

**Pattern:**

```regex
response\.sendRedirect\s*\(\s*(.*)\s*\)
```

**Explanation:**

- Finds redirects that might be used without validating the request origin.
- Check if redirects are based on user input without proper validation.

### **3.8. Absence of CSRF Filters in Web Configuration**

Manually inspect `web.xml` or Java-based configurations for CSRF filters.

---

<a name="examples"></a>
## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: Form Without CSRF Token**

**JSP Page:**

```jsp
<form action="/updateProfile" method="POST">
    <!-- Form fields -->
    <input type="text" name="email" />
    <input type="submit" value="Update" />
</form>
```

**Why It's Vulnerable:**

- The form does not include a CSRF token.
- Attackers can craft malicious requests that the server accepts because it cannot distinguish legitimate requests from forged ones.

**Regex Match Explanation:**

- The regex matches `<form action="/updateProfile" method="POST">`.
- No CSRF token field is present within the form.

### **4.2. Vulnerable Code Example: State-Changing GET Request**

```java
@RequestMapping(value = "/deleteAccount", method = RequestMethod.GET)
public String deleteAccount(Model model) {
    // Code to delete the user's account
    return "accountDeleted";
}
```

**Why It's Vulnerable:**

- Uses HTTP GET for a state-changing action (deleting an account).
- GET requests can be triggered by third-party sites via image tags, scripts, etc.

**Regex Match Explanation:**

- The regex identifies `@RequestMapping(value = "/deleteAccount", method = RequestMethod.GET)`.

### **4.3. Vulnerable Code Example: CSRF Protection Disabled**

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();
        // Other configurations
    }
}
```

**Why It's Vulnerable:**

- Disables CSRF protection entirely in the application.
- All POST requests are vulnerable to CSRF attacks.

**Regex Match Explanation:**

- The regex matches `http.csrf().disable();`.

### **4.4. Vulnerable Code Example: Inadequate CORS Configuration**

```java
@CrossOrigin(origins = "*", allowCredentials = "true")
@RestController
public class ApiController {
    // Controller methods
}
```

**Why It's Vulnerable:**

- Allows all origins (`origins = "*"`) to send cross-origin requests.
- With `allowCredentials = "true"`, cookies and authentication headers are included.
- Enables CSRF attacks from any origin.

**Regex Match Explanation:**

- The regex identifies `@CrossOrigin(origins = "*", allowCredentials = "true")`.

### **4.5. Vulnerable Code Example: Missing `HttpOnly` and `Secure` Flags**

```java
Cookie sessionCookie = new Cookie("SESSIONID", sessionId);
response.addCookie(sessionCookie);
```

**Why It's Vulnerable:**

- The cookie lacks `HttpOnly` and `Secure` flags.
- Although this is more related to XSS, lack of these flags can exacerbate CSRF risks.

**Regex Match Explanation:**

- The code shows cookie creation without setting security attributes.

---

<a name="interpreting-findings"></a>
## **5. Interpreting and Validating Findings**

- **Identify Forms and State-Changing Actions:**

  - Review forms and endpoints that perform actions like creating, updating, or deleting data.
  - Check if CSRF tokens are included and validated on the server side.

- **Review HTTP Methods:**

  - Ensure that state-changing actions use HTTP POST, PUT, DELETE methods, not GET.
  - Verify that GET requests do not modify server state.

- **Check Security Configurations:**

  - Look for configurations that disable CSRF protection.
  - Ensure that CSRF protection mechanisms are properly enabled and configured.

- **Validate CORS Policies:**

  - Analyze `@CrossOrigin` annotations and CORS configurations.
  - Ensure that cross-origin requests are restricted to trusted origins.

- **Examine Cookie Settings:**

  - Confirm that session cookies have `HttpOnly`, `Secure`, and `SameSite` attributes set appropriately.
  - `SameSite` can help mitigate CSRF by restricting when cookies are sent.

- **Understand the Context:**

  - Determine if the application relies on other mechanisms (e.g., tokens in headers) for CSRF protection.
  - Be aware of false positives where security measures are implemented differently.

**Example:**

- If a form lacks a CSRF token but the application uses a custom header for CSRF protection, the risk may be mitigated.
- If CSRF protection is disabled in development configurations but enabled in production, document the discrepancy and recommend aligning environments.

---

<a name="prevention"></a>
## **6. Best Practices for Prevention**

### **6.1. Implement Anti-CSRF Tokens**

- **Use CSRF Tokens:**

  - Generate a unique token per user session.
  - Include the token as a hidden field in forms or as a request parameter.
  - Validate the token on the server side.

**Example in Spring Security:**

```jsp
<form action="/updateProfile" method="POST">
    <input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />
    <!-- Form fields -->
</form>
```

### **6.2. Use HTTP POST for State-Changing Requests**

- **Restrict GET Requests:**

  - Use GET only for safe, idempotent requests that do not change server state.
  - Use POST, PUT, DELETE for actions that modify data.

### **6.3. Enable CSRF Protection in Frameworks**

- **Spring Security:**

  - By default, CSRF protection is enabled.
  - Do not disable it unless absolutely necessary.

**Example:**

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // CSRF protection is enabled by default
        // No need to explicitly enable unless custom configurations are needed
    }
}
```

### **6.4. Set Cookie Attributes Appropriately**

- **Use `HttpOnly`, `Secure`, and `SameSite` Attributes:**

  - `HttpOnly`: Prevents client-side scripts from accessing the cookie.
  - `Secure`: Ensures the cookie is sent over HTTPS only.
  - `SameSite`: Controls when cookies are sent with cross-origin requests.

**Example:**

```java
Cookie sessionCookie = new Cookie("SESSIONID", sessionId);
sessionCookie.setHttpOnly(true);
sessionCookie.setSecure(true);
sessionCookie.setPath("/");
sessionCookie.setMaxAge(1800); // 30 minutes
sessionCookie.setAttribute("SameSite", "Strict");
response.addCookie(sessionCookie);
```

### **6.5. Validate the Origin of Requests**

- **Check `Origin` and `Referer` Headers:**

  - Ensure that requests originate from allowed domains.
  - Be cautious as headers can be spoofed but can add an extra layer of defense.

**Example:**

```java
String origin = request.getHeader("Origin");
if (origin == null || !origin.equals("https://trusted.domain.com")) {
    response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid Origin");
    return;
}
```

### **6.6. Configure CORS Policies Carefully**

- **Restrict Allowed Origins:**

  - Specify exact domains rather than using wildcards (`*`).
  - Do not set `allowCredentials` to `true` unless necessary.

**Example:**

```java
@CrossOrigin(origins = "https://trusted.domain.com")
@RestController
public class ApiController {
    // Controller methods
}
```
