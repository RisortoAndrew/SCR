## **1. Introduction to CRLF Injection**

### **1.1. Overview of CRLF Injection**

**Carriage Return Line Feed (CRLF) Injection** is a type of security vulnerability that occurs when an application incorporates untrusted user input into HTTP headers or other protocols that use CRLF characters (`\r\n`) to terminate lines. This vulnerability allows an attacker to inject additional headers or manipulate the structure of the response, leading to various attacks such as:

- **HTTP Response Splitting**
- **Cross-Site Scripting (XSS)**
- **Session Fixation**
- **Cache Poisoning**

**Key Concepts:**

- **CRLF Characters:** In HTTP and many other protocols, `\r\n` (Carriage Return and Line Feed) signify the end of a line.
- **HTTP Response Headers:** Consist of key-value pairs, separated by `:` and terminated by CRLF characters.
- **HTTP Response Splitting:** Occurs when an attacker injects CRLF characters, creating additional responses or manipulating the response body.

### **1.2. Why CRLF Injection Occurs**

CRLF Injection occurs when:

- **Unvalidated User Input:** User-supplied data is incorporated into HTTP headers without proper validation or sanitization.
- **Improper Encoding:** Failing to encode or sanitize input that is used in header values.
- **Dynamic Header Construction:** Headers are built using string concatenation with untrusted input.

### **1.3. Consequences of CRLF Injection**

- **HTTP Response Splitting:** Allows an attacker to create additional HTTP responses, potentially injecting malicious content.
- **Cross-Site Scripting (XSS):** Injecting scripts into the response body.
- **Cache Poisoning:** Manipulating cached responses to serve malicious content to other users.
- **Session Hijacking:** Setting cookies or altering session identifiers.

---

<a name="vulnerable-patterns"></a>
## **2. Common Vulnerable Patterns in Java Applications**

Vulnerabilities arise when developers improperly handle user input in relation to HTTP headers or protocols using CRLF termination.

### **2.1. Incorporating User Input into HTTP Headers**

- **Dynamic Header Values:** Using user input directly in header values.
- **Setting Cookies with Untrusted Input:** Including user input in cookie values without validation.

### **2.2. Lack of Input Validation and Sanitization**

- **No Validation:** Accepting user input without checking for CRLF characters or malicious patterns.
- **No Encoding:** Failing to encode or sanitize input before incorporating it into headers.

### **2.3. Improper Use of Header APIs**

- **Using `response.setHeader()` with Untrusted Data:** Directly setting headers with user input.
- **String Concatenation in Headers:** Building header strings using concatenation without proper handling.

### **2.4. Custom Header Construction**

- **Manual Header Management:** Writing custom code to manage headers, increasing the risk of injection.

### **2.5. Misuse of URL Redirection**

- **Including User Input in Redirects:** Using `response.sendRedirect()` with unvalidated parameters that may be manipulated to include CRLF sequences.

---

<a name="detection-methods"></a>
## **3. Regex Patterns and Manual Methods for Detection**

Since you have no access to automated tools, manually inspect your Java code using the following patterns and methods.

### **3.1. Identifying Header Manipulation**

**Pattern:**

```java
response\.setHeader\s*\(\s*".*"\s*,\s*.*\)
response\.addHeader\s*\(\s*".*"\s*,\s*.*\)
```

**Explanation:**

- Finds where the application sets or adds HTTP headers.
- Focus on instances where header values include user input.

### **3.2. Detecting User Input in Header Values**

**Pattern:**

```java
response\.(setHeader|addHeader)\s*\(\s*".*"\s*,\s*.*request\.getParameter\s*\(\s*".*"\s*\).*\)
```

**Explanation:**

- Identifies headers being set with values derived from user input.
- Review such usages for potential CRLF injection vulnerabilities.

### **3.3. Searching for Unvalidated Input in Cookies**

**Pattern:**

```java
Cookie\s+.*=\s*new\s+Cookie\s*\(\s*".*"\s*,\s*.*request\.getParameter\s*\(\s*".*"\s*\).*\)
response\.addCookie\s*\(\s*.*\s*\)
```

**Explanation:**

- Detects cookies being created with user input.
- Verify if the input is properly validated or sanitized.

### **3.4. Checking for Improper Use of `sendRedirect`**

**Pattern:**

```java
response\.sendRedirect\s*\(\s*.*request\.getParameter\s*\(\s*".*"\s*\).*\)
```

**Explanation:**

- Finds redirects using user-supplied data.
- User input may be manipulated to include CRLF characters.

### **3.5. Identifying Custom Header Construction**

**Pattern:**

```java
out\.write\s*\(\s*"HTTP/1\.[01]\s+200\s+OK\r\n.*"\s*\)
```

**Explanation:**

- Looks for manual construction of HTTP responses.
- Manually written headers are prone to CRLF injection.

### **3.6. Searching for Lack of Input Validation**

**Pattern:**

- Check for absence of validation methods or sanitization functions around user input.

**Manual Method:**

- Identify where user input is accepted and see if validation is performed.

### **3.7. Detecting Use of Unvalidated Query Parameters**

**Pattern:**

```java
String\s+.*\s*=\s*request\.getQueryString\s*\(\s*\)
```

**Explanation:**

- Retrieves the entire query string, which may contain malicious input.
- Ensure proper validation before use.

---

<a name="examples"></a>
## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: User Input in Header Values**

```java
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String filename = request.getParameter("filename");
    response.setHeader("Content-Disposition", "attachment; filename=" + filename);
    // Rest of the code
}
```

**Why It's Vulnerable:**

- **Unvalidated User Input in Header:** The `filename` parameter is directly included in the `Content-Disposition` header.
- **Potential Attack:**
  - An attacker can supply a `filename` containing CRLF characters, injecting additional headers or modifying the response body.

**Regex Match Explanation:**

- Matches `response.setHeader("Content-Disposition", "attachment; filename=" + filename);` where `filename` is from user input.

### **4.2. Vulnerable Code Example: Unvalidated Input in Cookies**

```java
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String sessionId = request.getParameter("sessionId");
    Cookie cookie = new Cookie("JSESSIONID", sessionId);
    response.addCookie(cookie);
    // Rest of the code
}
```

**Why It's Vulnerable:**

- **User Input in Cookie Value:** The `sessionId` parameter is used directly in the cookie value.
- **Potential Attack:**
  - An attacker can inject CRLF characters to set additional cookies or headers.

**Regex Match Explanation:**

- Matches `new Cookie("JSESSIONID", sessionId);` where `sessionId` is from user input.

### **4.3. Vulnerable Code Example: Improper Use of `sendRedirect`**

```java
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String url = request.getParameter("url");
    response.sendRedirect(url);
}
```

**Why It's Vulnerable:**

- **Unvalidated Redirect:** The `url` parameter is used directly in the redirect.
- **Potential Attack:**
  - An attacker can inject CRLF characters into the `url`, affecting the response headers.

**Regex Match Explanation:**

- Matches `response.sendRedirect(url);` where `url` is from user input.

### **4.4. Vulnerable Code Example: Custom Header Construction**

```java
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String status = request.getParameter("status");
    PrintWriter out = response.getWriter();
    out.write("HTTP/1.1 " + status + " OK\r\n");
    out.write("Content-Type: text/html\r\n");
    out.write("\r\n");
    out.write("<html><body>Response</body></html>");
}
```

**Why It's Vulnerable:**

- **Manual Response Writing:** The code manually constructs the HTTP response using user input.
- **Potential Attack:**
  - An attacker can manipulate `status` to inject CRLF sequences and additional headers.

**Regex Match Explanation:**

- Matches `out.write("HTTP/1.1 " + status + " OK\r\n");` where `status` is from user input.

### **4.5. Vulnerable Code Example: No Input Validation**

```java
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String headerName = request.getParameter("headerName");
    String headerValue = request.getParameter("headerValue");
    response.setHeader(headerName, headerValue);
    // Rest of the code
}
```

**Why It's Vulnerable:**

- **User-Controlled Header Names and Values:** Both header name and value are derived from user input without validation.
- **Potential Attack:**
  - An attacker can inject CRLF characters into the header name or value, manipulating the response.

**Regex Match Explanation:**

- Matches `response.setHeader(headerName, headerValue);` with `headerName` and `headerValue` from user input.

---

<a name="interpreting-findings"></a>
## **5. Interpreting and Validating Findings**

When analyzing potential CRLF injection vulnerabilities:

- **Assess Input Sources:**

  - Identify where user input is accepted.
  - Determine if input is validated or sanitized.

- **Review Header Manipulations:**

  - Check how headers are set and where user input is included.
  - Look for direct inclusion of untrusted data in headers.

- **Evaluate Input Validation and Encoding:**

  - Ensure that user input is validated for illegal characters.
  - Confirm that CRLF characters are properly handled or encoded.

- **Understand the Context:**

  - Consider how the application uses headers and the impact of manipulated headers.
  - Assess the potential impact of injected CRLF sequences.

- **Consider Abuse Cases:**

  - Think about how an attacker might manipulate inputs to exploit the vulnerability.
  - Evaluate whether the vulnerability could lead to HTTP response splitting, XSS, or other attacks.

**Example Validation:**

- In the `doGet` method that sets the `Content-Disposition` header, verify whether the `filename` parameter is validated to prevent CRLF characters.

---

<a name="prevention"></a>
## **6. Best Practices for Prevention**

### **6.1. Validate and Sanitize User Input**

- **Input Validation:**

  - Implement whitelisting to accept only expected input formats.
  - Reject inputs containing CRLF characters or other illegal sequences.

- **Example:**

  ```java
  String filename = request.getParameter("filename");
  if (!filename.matches("^[a-zA-Z0-9._-]{1,100}$")) {
      throw new IllegalArgumentException("Invalid filename");
  }
  ```

### **6.2. Encode Header Values Properly**

- **Use Built-in Encoding Methods:**

  - Encode header values to prevent injection of special characters.

- **Example:**

  ```java
  String safeFilename = URLEncoder.encode(filename, "UTF-8");
  response.setHeader("Content-Disposition", "attachment; filename=" + safeFilename);
  ```

### **6.3. Avoid Direct Inclusion of User Input in Headers**

- **Do Not Trust User Input for Headers:**

  - Use fixed header names and values wherever possible.

- **Example:**

  ```java
  response.setHeader("Content-Type", "text/html");
  ```

### **6.4. Sanitize Header Names and Values**

- **Validate Header Names:**

  - Ensure header names conform to allowed characters.

- **Escape or Remove Illegal Characters:**

  - Replace or remove CRLF characters from header values.

- **Example:**

  ```java
  String headerValue = request.getParameter("headerValue");
  headerValue = headerValue.replaceAll("[\\r\\n]", "");
  response.setHeader("X-Custom-Header", headerValue);
  ```

### **6.5. Use Frameworks and Libraries Safely**

- **Leverage Trusted Libraries:**

  - Use established frameworks that handle header encoding and prevent injection.

### **6.6. Implement Content Security Policy (CSP)**

- **Configure CSP Headers:**

  - Use CSP to mitigate the impact of injected scripts.

- **Example:**

  ```java
  response.setHeader("Content-Security-Policy", "default-src 'self'");
  ```