## **1. Introduction to Cross-Origin Resource Sharing (CORS) and Common Vulnerabilities**

### **1.1. Overview of CORS**

**Cross-Origin Resource Sharing (CORS)** is a mechanism that allows web applications running on one domain (origin) to request resources from another domain. By default, web browsers enforce the **Same-Origin Policy**, which restricts scripts from making requests to a different origin than the one that served the web page.

CORS relaxes this restriction by enabling servers to specify which origins are permitted to access their resources via specific HTTP headers.

**Key Concepts:**

- **Origin:** Defined by the scheme (protocol), host (domain), and port.
- **CORS Preflight Request:** A preliminary request made using the `OPTIONS` method to determine whether the actual request is safe to send.
- **CORS Headers:**
  - **`Access-Control-Allow-Origin`**
  - **`Access-Control-Allow-Methods`**
  - **`Access-Control-Allow-Headers`**
  - **`Access-Control-Allow-Credentials`**
  - **`Access-Control-Max-Age`**
  - **`Access-Control-Expose-Headers`**

### **1.2. Common CORS Vulnerabilities**

Misconfiguration of CORS headers can lead to significant security risks:

- **Overly Permissive Policies:**
  - Allowing all origins (`*`) when sensitive data is accessible.
  - Reflecting the `Origin` header without proper validation.

- **Credentials Misconfiguration:**
  - Setting `Access-Control-Allow-Credentials: true` with a wildcard `Access-Control-Allow-Origin` or without proper origin validation.

- **Exploitable Origin Validation:**
  - Using regular expressions or string operations that can be bypassed (e.g., subdomain or null origin bypasses).

- **Preflight Request Handling Issues:**
  - Incorrectly handling `OPTIONS` requests, leading to unintended exposure.

- **Exposed Internal APIs:**
  - Allowing cross-origin access to internal APIs not intended for public use.

**Consequences of CORS Vulnerabilities Include:**

- **Unauthorized Access:** Attackers can read sensitive data from the victim's browser.
- **Cross-Site Request Forgery (CSRF):** When combined with other vulnerabilities, attackers can perform actions on behalf of users.
- **Data Leakage:** Exposure of sensitive information to untrusted origins.

---

<a name="vulnerable-patterns"></a>
## **2. Common Vulnerable Patterns in Java Applications**

Vulnerabilities arise when developers misconfigure CORS settings or improperly handle origin validation.

### **2.1. Allowing All Origins Indiscriminately**

- **Setting `Access-Control-Allow-Origin` to `*`:**
  - Especially dangerous when `Access-Control-Allow-Credentials` is `true`.

### **2.2. Reflecting the `Origin` Header Without Validation**

- **Dynamic Origin Reflection:**
  - Echoing back the `Origin` header value in `Access-Control-Allow-Origin` without checking if it's a trusted origin.

### **2.3. Improper Origin Validation**

- **Weak String Matching:**
  - Using `endsWith()`, `contains()`, or regex patterns that can be bypassed.

- **Subdomain Inclusion Without Proper Checks:**
  - Allowing all subdomains (`*.example.com`) without considering control over subdomains.

### **2.4. Misconfiguration of `Access-Control-Allow-Credentials`**

- **Combining `Access-Control-Allow-Credentials: true` with Wildcards:**
  - Wildcard origins or methods with credentials allowed.

### **2.5. Incorrect Preflight Request Handling**

- **Not Handling `OPTIONS` Requests Properly:**
  - Failing to respond correctly to preflight requests, leading to unintended access.

### **2.6. Exposing Sensitive Endpoints**

- **Applying CORS Settings Globally:**
  - Allowing cross-origin requests to endpoints that should be restricted.

### **2.7. Misuse of CORS Libraries or Filters**

- **Misconfiguring CORS Filters:**
  - Using default settings that are insecure.

- **Custom CORS Implementations:**
  - Implementing CORS handling manually without proper security considerations.

---

<a name="detection-methods"></a>
## **3. Regex Patterns and Manual Methods for Detection**

Since you have no access to automated tools, you can manually inspect your Java application's code to identify potential CORS vulnerabilities.

### **3.1. Identifying CORS Configuration**

**Pattern:**

```java
import\s+org\.springframework\.web\.cors\..*
import\s+org\.springframework\.web\.filter\.CorsFilter
import\s+javax\.servlet\.Filter
import\s+javax\.servlet\.http\..*
```

**Explanation:**

- Identifies imports related to CORS configuration and filters.
- Focus your review on classes that handle CORS settings.

### **3.2. Detecting `Access-Control-Allow-Origin` Set to `*`**

**Pattern:**

```java
response\.setHeader\s*\(\s*"Access-Control-Allow-Origin"\s*,\s*"\\*"\s*\)
```

**Explanation:**

- Finds where the application sets `Access-Control-Allow-Origin` to `*`.
- Review the context to see if credentials are allowed or sensitive data is exposed.

### **3.3. Searching for Dynamic Origin Reflection**

**Pattern:**

```java
String\s+origin\s*=\s*request\.getHeader\s*\(\s*"Origin"\s*\);
response\.setHeader\s*\(\s*"Access-Control-Allow-Origin"\s*,\s*origin\s*\)
```

**Explanation:**

- Detects where the `Origin` header value is directly used in `Access-Control-Allow-Origin`.
- Check if any validation is performed on the `origin` variable.

### **3.4. Identifying Improper Origin Validation**

**Pattern:**

```java
if\s*\(\s*origin\.endsWith\s*\(\s*".*"\s*\)\s*\)\s*\{
\s*response\.setHeader\s*\(\s*"Access-Control-Allow-Origin"\s*,\s*origin\s*\);
```

**Explanation:**

- Finds code that allows origins based on `endsWith()`.
- Review for possible bypasses (e.g., `example.com.evil.com`).

**Alternative Pattern:**

```java
origin\.matches\s*\(\s*".*"\s*\)
```

- Checks for regex patterns that may be too permissive.

### **3.5. Checking for `Access-Control-Allow-Credentials` Misconfiguration**

**Pattern:**

```java
response\.setHeader\s*\(\s*"Access-Control-Allow-Credentials"\s*,\s*"true"\s*\)
```

**Explanation:**

- Identifies where credentials are allowed.
- Ensure that `Access-Control-Allow-Origin` is not set to `*` or improperly validated.

### **3.6. Reviewing CORS Filters and Interceptors**

**Pattern:**

```java
public\s+class\s+\w+\s+implements\s+Filter
public\s+class\s+\w+\s+extends\s+CorsFilter
```

**Explanation:**

- Finds custom filters that may handle CORS.
- Review their implementations for security issues.

### **3.7. Inspecting Global CORS Configurations**

**Pattern:**

- For Spring Boot applications:

```java
@Configuration
public\s+class\s+\w+\s+implements\s+WebMvcConfigurer
```

- Then look for:

```java
public\s+void\s+addCorsMappings\s*\(CorsRegistry\s+registry\)\s*\{
.*registry\.addMapping\s*\(\s*"/\*\*"\s*\).*
```

**Explanation:**

- Identifies global CORS configurations that may affect all endpoints.
- Check the allowed origins and methods.

### **3.8. Searching for Missing Preflight Request Handling**

**Pattern:**

- Check for absence of handling for `OPTIONS` method:

```java
@RequestMapping\(method\s*=\s*RequestMethod\.OPTIONS.*\)
```

**Explanation:**

- If preflight requests are not properly handled, the server may unintentionally allow access.

### **3.9. Identifying Exposed Internal APIs**

**Manual Method:**

- Review API endpoints and determine if they should be accessible cross-origin.
- Check CORS configurations applied to these endpoints.

---

<a name="examples"></a>
## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: Allowing All Origins Indiscriminately**

```java
public class SimpleCORSFilter implements Filter {

    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
        throws IOException, ServletException {

        HttpServletResponse response = (HttpServletResponse) res;
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
        chain.doFilter(req, res);
    }
}
```

**Why It's Vulnerable:**

- **Wildcard Origin:** `Access-Control-Allow-Origin` is set to `*`, allowing any origin to access the resources.
- **Potential Exploit:**
  - If sensitive data or functionalities are accessible, any website can make cross-origin requests and read the responses.

**Regex Match Explanation:**

- Matches `response.setHeader("Access-Control-Allow-Origin", "*");`.

### **4.2. Vulnerable Code Example: Reflecting Origin Without Validation**

```java
public class DynamicCORSFilter implements Filter {

    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
        throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;
        String origin = request.getHeader("Origin");
        response.setHeader("Access-Control-Allow-Origin", origin);
        response.setHeader("Access-Control-Allow-Credentials", "true");
        chain.doFilter(req, res);
    }
}
```

**Why It's Vulnerable:**

- **Unvalidated Origin Reflection:** The `Origin` header is directly used without checking if it's trusted.
- **Credentials Allowed:** `Access-Control-Allow-Credentials` is set to `true`, increasing the risk.
- **Potential Exploit:**
  - Attackers can set the `Origin` header to their own domain and access sensitive data with the victim's credentials.

**Regex Match Explanation:**

- Matches the pattern where `origin` is obtained from `request.getHeader("Origin")` and directly set in `Access-Control-Allow-Origin`.

### **4.3. Vulnerable Code Example: Improper Origin Validation**

```java
public class WeakValidationCORSFilter implements Filter {

    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
        throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;
        String origin = request.getHeader("Origin");
        if (origin.endsWith(".example.com")) {
            response.setHeader("Access-Control-Allow-Origin", origin);
            response.setHeader("Access-Control-Allow-Credentials", "true");
        }
        chain.doFilter(req, res);
    }
}
```

**Why It's Vulnerable:**

- **Weak Matching with `endsWith()`:** An attacker can use a malicious domain like `attack.example.com.evil.com`.
- **Potential Exploit:**
  - Bypass the origin check and access resources with credentials.

**Regex Match Explanation:**

- Matches `if (origin.endsWith(".example.com"))`.

### **4.4. Vulnerable Code Example: Misconfigured Global CORS in Spring Boot**

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins("*")
            .allowedMethods("*")
            .allowCredentials(true);
    }
}
```

**Why It's Vulnerable:**

- **Wildcard Origin with Credentials:** `allowedOrigins("*")` combined with `allowCredentials(true)` is insecure.
- **Global Application:** Applies to all endpoints, potentially exposing sensitive APIs.

**Regex Match Explanation:**

- Matches `allowedOrigins("*")` and `allowCredentials(true)`.

### **4.5. Vulnerable Code Example: Missing Preflight Request Handling**

```java
@RestController
@RequestMapping("/api")
public class ApiController {

    @PostMapping("/data")
    public ResponseEntity<String> postData(@RequestBody String data) {
        // Process data
        return ResponseEntity.ok("Data received");
    }
}
```

**Why It's Vulnerable:**

- **No Handling of `OPTIONS` Requests:** Preflight requests may not be correctly processed.
- **Potential Exploit:**
  - The server may respond with default headers, unintentionally allowing cross-origin access.

**Manual Detection:**

- Absence of `@RequestMapping(method = RequestMethod.OPTIONS)` or equivalent handling.

---

<a name="interpreting-findings"></a>
## **5. Interpreting and Validating Findings**

When analyzing potential CORS vulnerabilities:

- **Assess the Context:**
  - Determine if the resources being exposed contain sensitive data or functionalities.
  - Understand the application's intended CORS policy.

- **Evaluate Origin Validation Logic:**
  - Check if origin validation is robust and cannot be bypassed.
  - Consider edge cases like subdomains, null origins, and special characters.

- **Analyze Header Configurations:**
  - Ensure `Access-Control-Allow-Origin` is set appropriately.
  - Verify that `Access-Control-Allow-Credentials` is used safely.

- **Review Preflight Handling:**
  - Confirm that `OPTIONS` requests are properly handled and do not expose unintended access.

- **Understand the Impact:**
  - Consider how an attacker could exploit the misconfiguration.
  - Assess the risk based on the data or functionality exposed.

**Example Validation:**

- In the `DynamicCORSFilter`, determine whether the application intentionally allows any origin with credentials or if it should restrict origins to trusted domains.

---

<a name="prevention"></a>
## **6. Best Practices for Prevention**

### **6.1. Restrict Allowed Origins**

- **Specify Trusted Origins Explicitly:**

  ```java
  response.setHeader("Access-Control-Allow-Origin", "https://trusted.example.com");
  ```

- **Avoid Wildcards with Credentials:**

  - Do not use `*` in `Access-Control-Allow-Origin` when `Access-Control-Allow-Credentials` is `true`.

### **6.2. Implement Robust Origin Validation**

- **Use Exact String Matching:**

  ```java
  List<String> allowedOrigins = Arrays.asList("https://trusted.example.com", "https://partner.example.org");
  if (allowedOrigins.contains(origin)) {
      response.setHeader("Access-Control-Allow-Origin", origin);
  }
  ```

- **Avoid `endsWith()` or `contains()` Methods:**

  - These can be bypassed with crafted domain names.

- **Consider Using URI Parsing:**

  ```java
  try {
      URI originUri = new URI(origin);
      String host = originUri.getHost();
      if ("trusted.example.com".equals(host)) {
          response.setHeader("Access-Control-Allow-Origin", origin);
      }
  } catch (URISyntaxException e) {
      // Handle exception
  }
  ```

### **6.3. Configure CORS Securely in Frameworks**

- **Spring Boot Example:**

  ```java
  @Configuration
  public class CorsConfig implements WebMvcConfigurer {

      @Override
      public void addCorsMappings(CorsRegistry registry) {
          registry.addMapping("/api/**")
              .allowedOrigins("https://trusted.example.com")
              .allowedMethods("GET", "POST")
              .allowCredentials(true);
      }
  }
  ```

- **Avoid Applying CORS Settings Globally:**

  - Limit CORS configurations to necessary endpoints.

### **6.4. Handle Preflight Requests Properly**

- **Implement `OPTIONS` Method Handling:**

  ```java
  @RequestMapping(value = "/api/data", method = RequestMethod.OPTIONS)
  public ResponseEntity<?> handleOptions() {
      HttpHeaders headers = new HttpHeaders();
      headers.add("Access-Control-Allow-Origin", "https://trusted.example.com");
      headers.add("Access-Control-Allow-Methods", "POST, GET, OPTIONS");
      headers.add("Access-Control-Allow-Headers", "Content-Type");
      return new ResponseEntity<>(headers, HttpStatus.OK);
  }
  ```