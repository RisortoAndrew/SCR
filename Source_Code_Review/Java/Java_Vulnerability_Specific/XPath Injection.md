# **Comprehensive Cheat Sheet for Identifying XPath Injection in Java**

---

## **1. Introduction**

**XPath Injection** occurs when untrusted user input is used to construct an XPath query string without proper validation or sanitization, enabling attackers to modify the query logic and gain unauthorized access to XML-based data.

---

## **2. Common Vulnerable Patterns in Java**

1. **Direct String Concatenation in XPath Queries**
    
    ```java
    String userInput = request.getParameter("username");
    String xpathQuery = "/users/user[username='" + userInput + "']";
    Node userNode = (Node) xPath.evaluate(xpathQuery, doc, XPathConstants.NODE);
    ```
    
    - Vulnerable because `userInput` is injected directly into the query.
2. **Complex or Nested XPath with Unvalidated User Input**
    
    ```java
    String search = request.getParameter("search");
    String xpathQuery = "//book[title[contains(., '" + search + "')]]";
    NodeList books = (NodeList) xPath.evaluate(xpathQuery, doc, XPathConstants.NODESET);
    ```
    
    - Attackers can insert special characters to alter the query logic.
3. **Minimal or No Validation**
    
    ```java
    String category = request.getParameter("category");
    String query = "/products/product[category='" + category + "']";
    NodeList results = (NodeList) xPath.evaluate(query, doc, XPathConstants.NODESET);
    ```
    
    - Even a length check is insufficient if special characters aren’t escaped.
4. **Ignoring Exceptions**
    
    ```java
    try {
        // parse and evaluate XPath
    } catch (Exception e) {
        // silently ignore
    }
    ```
    
    - Suppresses potential alerts for injection attempts.

---

## **3. Regex Patterns and Manual Methods for Detection**

Below are specific regex patterns (each in its own code block) to help locate potential XPath-injection hotspots in Java code. Use these to perform manual searches across your codebase.

### **3.1. Identifying XPath Library Usage**

Look for imports indicating the use of common XPath libraries. Each regex is in its own code block:

```regex
import\s+javax\.xml\.xpath\.\*
```

```regex
import\s+org\.jaxen\.\*
```

```regex
import\s+org\.apache\.xpath\.\*
```

```regex
import\s+net\.sf\.saxon\.\*
```

```regex
import\s+org\.w3c\.dom\.xpath\.\*
```

**Explanation:**  
Any file importing these packages potentially performs XPath operations. Focus your code review on them.

---

### **3.2. Finding Direct Query Construction**

Search for code that might be building query strings (e.g., concatenation, brackets, slashes). Each pattern is in its own code block:

```regex
String\s+\w+\s*=\s*".*?(?i)(/|//).*"
```

```regex
String\s+\w+\s*=\s*".*?\[.*"
```

```regex
String\s+\w+\s*=\s*.*\+.*(\]|').*
```

**Explanation:**  
These patterns help locate suspicious places where strings may contain XPath syntax (`/`, `//`, `[`, `]`, `'`) and possible concatenation (`+`).

---

### **3.3. Searching for `evaluate()` or Equivalent Methods**

XPath queries typically end up in methods like `evaluate()`, `selectNodes()`, or `selectSingleNode()`. Each regex is in its own code block:

```regex
evaluate\s*\(
```

```regex
selectNodes\s*\(
```

```regex
selectSingleNode\s*\(
```

**Explanation:**  
Manually trace any parameters passed into these methods to see if they contain unvalidated user input.

---

### **3.4. Detecting Suspicious User Input Usage in Queries**

Check if user input methods appear near XPath construction. Each regex is in its own code block:

```regex
(request\.getParameter|request\.getAttribute|session\.getAttribute)\(
```

**Explanation:**  
If these values are used directly in XPath queries without sanitization, it’s a red flag for possible injection.

---

### **3.5. Looking for Insecure Utility or Wrapper Classes**

Developers often encapsulate XPath logic in utility classes. Each regex is in its own code block:

```regex
public\s+class\s+.*XMLUtils
```

```regex
public\s+class\s+.*XPathUtils
```

**Explanation:**  
Review these classes for methods that build XPath queries. Pay special attention to any string concatenation involving user input.

---

## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code: Direct Concatenation**

```java
String userId = request.getParameter("userId");
String xpathQuery = "/users/user[@id='" + userId + "']";

XPath xPath = XPathFactory.newInstance().newXPath();
Node userNode = (Node) xPath.evaluate(xpathQuery, doc, XPathConstants.NODE);
```

**Why It's Vulnerable:**

- Injects `userId` directly, which may lead to manipulations like `'/users/user[@id='' or '1'='1']`.

---

### **4.2. Vulnerable Code: Complex Predicate Injection**

```java
String searchTerm = request.getParameter("search");
String xpathQuery = "//book[title[contains(., '" + searchTerm + "')]]";
NodeList books = (NodeList) xPath.evaluate(xpathQuery, doc, XPathConstants.NODESET);
```

**Why It's Vulnerable:**

- Attackers can break out of the `contains()` predicate and append new conditions or logical operators.

---

### **4.3. Vulnerable Code: Minimal Validation**

```java
String category = request.getParameter("category");
// developer only checks length, no special character filtering
if (category.length() < 20) {
    String query = "/catalog/product[category='" + category + "']";
    NodeList products = (NodeList) xPath.evaluate(query, doc, XPathConstants.NODESET);
}
```

**Why It's Vulnerable:**

- Special characters in `category` can still alter the query structure (e.g., `'] or '1'='1`).

---

## **5. Interpreting and Validating Findings**

When a regex pattern flags code:

1. **Trace the Input Source:** Confirm whether the data is user-controlled.
2. **Check for Sanitization or Escaping:** Look for methods that encode special XPath characters.
3. **Assess Logic Impact:** If the query returns sensitive data or performs critical checks (e.g., authentication), the risk is higher.
4. **Review Exception Handling:** Ensure no silent catches mask injection attempts.

---

## **6. Best Practices for Prevention**

1. **Parameterize Queries (If Possible):**
    
    - Use library-specific mechanisms to bind variables safely rather than direct string concatenation.
2. **Whitelisting & Strict Validation:**
    
    - Only permit known-safe characters (e.g., alphanumeric) for user-provided fields.
3. **Escape Special Characters:**
    
    - Implement or use a robust escaping library for `'`, `"`, `[`, `]`, `(`, `)`, etc.