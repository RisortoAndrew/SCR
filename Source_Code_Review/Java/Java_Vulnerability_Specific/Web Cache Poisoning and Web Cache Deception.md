## **1. Introduction to Web Cache Poisoning and Web Cache Deception**

**Web Cache Poisoning** is a technique where an attacker exploits the behavior of a web server and its caching mechanism to cache malicious HTTP responses. This causes the cache to serve poisoned content to other users, leading to various security issues such as Cross-Site Scripting (XSS), session hijacking, or serving incorrect data.

**Web Cache Deception** involves tricking a web server into caching sensitive data that should not be cached, such as personal user data, and then retrieving it from the cache.

**Consequences of these attacks include:**

- **Information Disclosure:** Exposing sensitive user data to unauthorized parties.
- **Cross-Site Scripting (XSS):** Injecting malicious scripts that execute in users' browsers.
- **Cache Poisoning DoS:** Serving invalid or malicious content to users.
- **Session Hijacking:** Stealing session tokens or authentication data.

**Key concepts:**

- **Caching Mechanisms:** Web caches store responses to reduce server load and improve performance.
- **Cache Keys:** The method by which caches determine whether a request matches a stored response.
- **Headers and Parameters:** Manipulation of headers like `Host`, `X-Forwarded-Host`, `X-Original-URL`, or query parameters can influence caching behavior.

Identifying and mitigating web cache poisoning and deception vulnerabilities is essential to protect users and ensure the integrity of web applications.

---

<a name="vulnerable-patterns"></a>
## **2. Common Vulnerable Patterns in Java**

Vulnerable patterns in Java applications related to web cache poisoning and deception include:

- **Inconsistent Cache Key Generation:**
  - Not properly handling query parameters or headers that affect the cache key.
- **Caching User-Specific Data:**
  - Caching responses that include personalized or sensitive information.
- **Trusting Unvalidated Headers:**
  - Using headers like `X-Forwarded-Host` or `X-Original-URL` without proper validation.
- **Improper Cache-Control Headers:**
  - Missing or incorrect `Cache-Control` or `Vary` headers.
- **Serving Different Content for Same URL:**
  - Generating different responses for the same URL based on headers or parameters not included in the cache key.
- **Lack of Input Validation:**
  - Accepting and processing malicious input that can alter responses.
- **Misconfigured Reverse Proxies or CDNs:**
  - Allowing external manipulation of caching behavior through proxies.

---

<a name="caching-mechanisms"></a>
## **3. Understanding Caching Mechanisms**

Before proceeding to detection methods, it's important to understand how caching works in web applications.

### **3.1. Cache Key Components**

- **URL Path and Query Parameters:** By default, caches may use the full URL (path and query string) as part of the cache key.
- **HTTP Method:** Typically only GET requests are cached.
- **Headers:** Some caches consider specific headers (like `Accept-Encoding`) in the cache key.

### **3.2. Cache-Control Headers**

- **`Cache-Control`:** Specifies directives for caching mechanisms.
  - `no-cache`: The response can be cached but must be validated with the server.
  - `no-store`: The response must not be cached.
  - `public`: The response may be cached by any cache.
  - `private`: The response is intended for a single user and must not be stored by shared caches.
  - `max-age`: Specifies the maximum amount of time a resource is considered fresh.

- **`Vary`:** Indicates which headers affect the cached response.
  - E.g., `Vary: Accept-Encoding` means that the cache should consider `Accept-Encoding` when serving cached content.

### **3.3. Reverse Proxies and CDNs**

- **Reverse Proxies:** Act as intermediaries between clients and servers, often caching responses.
- **CDNs:** Content Delivery Networks distribute content across multiple servers and may cache responses.

---

<a name="detection-methods"></a>
## **4. Regex Patterns and Manual Methods for Detection**

Since you have no access to automated tools, you can manually inspect your Java application's code and configurations to identify potential vulnerabilities.

### **4.1. Reviewing Cache-Control Headers in Responses**

- **Pattern:**

  ```java
  response\.setHeader\s*\(\s*"Cache-Control"\s*,\s*".*"\s*\)
  ```

- **Explanation:**

  - Finds where `Cache-Control` headers are set in the code.
  - Check if appropriate directives are used for sensitive data.

### **4.2. Usage of `request.getHeader()` Without Validation**

- **Pattern:**

  ```java
  request\.getHeader\s*\(\s*["'](X-Forwarded-Host|X-Forwarded-For|X-Original-URL|Host)["']\s*\)
  ```

- **Explanation:**

  - Identifies retrieval of headers that can be manipulated by attackers.
  - Look for uses in constructing URLs or generating responses.

### **4.3. Dynamic Content Served Without Proper Caching Headers**

- **Pattern:**

  ```java
  response\.getWriter\(\)\.write\s*\(.*\)
  ```

- **Explanation:**

  - Finds code where responses are written.
  - Check if dynamic content is served without setting `Cache-Control` headers.

### **4.4. Inclusion of Query Parameters in Responses**

- **Pattern:**

  ```java
  request\.getParameter\s*\(\s*.*\s*\)
  ```

- **Explanation:**

  - Finds where query parameters are used in generating responses.
  - Verify if responses are cached without considering these parameters.

### **4.5. Usage of `HttpServletResponseWrapper` or Custom Response Classes**

- **Pattern:**

  ```java
  extends\s+HttpServletResponseWrapper
  ```

- **Explanation:**

  - Identifies custom response wrappers that may alter caching behavior.

### **4.6. Lack of `Vary` Header Configuration**

- **Manual Inspection:**

  - Check code and configurations for absence of `Vary` header settings.
  - Ensure that headers affecting content are included in `Vary`.

### **4.7. Misconfigured URL Rewriting or Mapping**

- **Pattern:**

  ```java
  response\.sendRedirect\s*\(.*\)
  ```

- **Explanation:**

  - Finds code that redirects based on user input.
  - Verify if redirections can be manipulated to cache unintended content.

### **4.8. Inclusion of User-Specific Data in Responses**

- **Pattern:**

  ```java
  session\.getAttribute\s*\(.*\)
  ```

- **Explanation:**

  - Finds where session data is used in responses.
  - Check if such responses are cached and served to other users.

---

<a name="examples"></a>
## **5. Detailed Examples and Explanations**

### **5.1. Vulnerable Code Example: Caching User-Specific Data**

```java
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String username = (String) request.getSession().getAttribute("username");
    response.getWriter().write("<html><body>Welcome, " + username + "</body></html>");
}
```

**Why It's Vulnerable:**

- **User-Specific Data:**

  - The response includes the `username` from the session.
  - If the response is cached, other users may receive content intended for a specific user.

- **Missing Cache-Control Headers:**

  - No `Cache-Control` headers are set.
  - The response may be cached by intermediaries or the browser.

**Regex Match Explanation:**

- The code uses `session.getAttribute("username")` and `response.getWriter().write(...)` without setting caching headers.

### **5.2. Vulnerable Code Example: Trusting Unvalidated Headers**

```java
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String host = request.getHeader("Host");
    String imageUrl = "https://" + host + "/images/logo.png";
    response.getWriter().write("<img src=\"" + imageUrl + "\" />");
}
```

**Why It's Vulnerable:**

- **Unvalidated Host Header:**

  - The `Host` header is used directly without validation.
  - An attacker can manipulate the `Host` header to inject arbitrary content.

- **Potential for Cache Poisoning:**

  - The response may be cached based on the URL, serving malicious content to others.

**Regex Match Explanation:**

- The regex matches `request.getHeader("Host")`.

### **5.3. Vulnerable Code Example: Missing `Vary` Header**

```java
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String language = request.getHeader("Accept-Language");
    if (language != null && language.startsWith("es")) {
        response.getWriter().write("Hola Mundo");
    } else {
        response.getWriter().write("Hello World");
    }
}
```

**Why It's Vulnerable:**

- **Content Varies by Header:**

  - The response content changes based on the `Accept-Language` header.

- **Missing `Vary` Header:**

  - The `Vary: Accept-Language` header is not set.
  - Caches may serve the wrong language version to users.

**Regex Match Explanation:**

- The code uses `request.getHeader("Accept-Language")` but does not set the `Vary` header.

### **5.4. Vulnerable Code Example: Inconsistent Cache Key Generation**

```java
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String productId = request.getParameter("id");
    String discountCode = request.getParameter("discount");
    Product product = getProductById(productId, discountCode);
    response.getWriter().write(renderProductPage(product));
}
```

**Why It's Vulnerable:**

- **Query Parameters Affect Content:**

  - The `discountCode` parameter changes the product price.

- **Cache Key Issues:**

  - If the cache key does not include `discountCode`, the response with a discounted price may be served to users without the code.

**Regex Match Explanation:**

- The code uses `request.getParameter("discount")` in generating the response.

---

<a name="interpreting-findings"></a>
## **6. Interpreting and Validating Findings**

- **Identify Sensitive Content:**

  - Look for responses that include user-specific data or sensitive information.

- **Check Cache-Control Headers:**

  - Verify if appropriate `Cache-Control` headers are set (e.g., `private`, `no-store`).

- **Assess Header Usage:**

  - Determine if unvalidated headers are used in constructing responses.

- **Review Vary Headers:**

  - Ensure that any headers affecting content are included in the `Vary` header.

- **Understand Caching Behavior:**

  - Consider how reverse proxies, CDNs, and browsers may cache responses.

- **Analyze Query Parameters:**

  - Check if query parameters that alter content are properly handled in caching mechanisms.

**Example:**

- If a response varies based on a query parameter, but the cache key does not consider that parameter, cached responses may be incorrect.

---

<a name="prevention"></a>
## **7. Best Practices for Prevention**

### **7.1. Set Appropriate Cache-Control Headers**

- **Control Caching Behavior:**

  - Use `Cache-Control` headers to specify how responses should be cached.

**Examples:**

- **For User-Specific Data:**

  ```java
  response.setHeader("Cache-Control", "private, no-store, no-cache, must-revalidate");
  response.setHeader("Pragma", "no-cache");
  ```

- **For Publicly Cacheable Content:**

  ```java
  response.setHeader("Cache-Control", "public, max-age=3600");
  ```

### **7.2. Include `Vary` Headers When Necessary**

- **Specify Headers Affecting Content:**

  - Use the `Vary` header to indicate which headers the cache should consider.

**Example:**

```java
response.setHeader("Vary", "Accept-Language");
```

### **7.3. Validate and Sanitize Headers and Parameters**

- **Do Not Trust Unvalidated Headers:**

  - Validate headers like `Host`, `X-Forwarded-Host`, `X-Original-URL` before using them.

**Example:**

```java
String host = request.getHeader("Host");
if (!isValidHost(host)) {
    host = "default.domain.com";
}
```