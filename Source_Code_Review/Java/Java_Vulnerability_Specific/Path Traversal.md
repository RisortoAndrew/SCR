## **1. Introduction to Path Traversal**

**Path Traversal**, also known as **Directory Traversal**, is a security vulnerability that allows attackers to access files and directories that are stored outside the web root folder. By manipulating variables that reference files with `../` sequences and their variations, attackers can navigate the file system to access sensitive files, such as configuration files, password files, or other critical system files.

In Java applications, this vulnerability arises when user-controlled input is used to construct file paths without proper validation or sanitization. Identifying and mitigating Path Traversal vulnerabilities is crucial to protect sensitive data and maintain application security.

---

<a name="vulnerable-patterns"></a>
## **2. Common Vulnerable Patterns in Java**

Vulnerable patterns in Java applications that can lead to Path Traversal include:

- **Constructing File Paths with User Input**: Using user-supplied data to build file paths without proper validation.
- **Reading or Writing Files Based on User Input**: Allowing users to specify file names or paths for reading, writing, or uploading files.
- **Use of APIs Without Secure Configuration**: Using file APIs like `File`, `FileInputStream`, `FileOutputStream`, `Files`, `FileChannel`, etc., with unvalidated input.
- **Improper Canonicalization**: Failing to resolve the actual filesystem path, allowing bypasses of security checks.

---

<a name="regex-patterns"></a>
## **3. Regex Patterns for Detection**

Below are regex patterns designed to identify potential Path Traversal vulnerabilities in Java code. These patterns can be used in VS Code's global search functionality.

### **3.1. Construction of `File` Objects with User Input**

**Pattern**:

```regex
new\s+File\s*\(\s*([^\)]+)\s*\)
```

**Explanation**:

- Detects instantiation of `File` objects.
- Captures the arguments passed to the `File` constructor.

### **3.2. File Operations with User-Supplied Paths**

**Pattern**:

```regex
(FileInputStream|FileOutputStream|FileReader|FileWriter|Files\.\w+)\s*\(\s*([^\)]+)\s*\)
```

**Explanation**:

- Identifies use of file stream classes with parameters that may include user input.

### **3.3. Use of `getResourceAsStream` or `getResource` with User Input**

**Pattern**:

```regex
(getResourceAsStream|getResource)\s*\(\s*([^\)]+)\s*\)
```

**Explanation**:

- Finds cases where resources are loaded using user-controlled paths.

### **3.4. Concatenation or Formatting of File Paths**

**Pattern**:

```regex
("|\+)\s*\+\s*(request\.getParameter|session\.getAttribute|[^\s\+;]+)\s*\+\s*("|\+)
```

**Explanation**:

- Captures string concatenations involving user input, which may be used to build file paths.

### **3.5. Reading System Properties or Environment Variables**

**Pattern**:

```regex
System\.(getProperty|getenv)\s*\(\s*([^\)]+)\s*\)
```

**Explanation**:

- Detects use of system properties or environment variables, which may be manipulated.

### **3.6. Use of Servlet Multipart APIs**

**Pattern**:

```regex
Part\s+\w+\s*=\s*request\.getPart\s*\(\s*([^\)]+)\s*\)
```

**Explanation**:

- Finds file upload handling code, which may include file path manipulation.

---

<a name="examples"></a>
## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: Constructing File Paths with User Input**

```java
String filename = request.getParameter("filename");
File file = new File("/var/www/uploads/" + filename);
FileInputStream fis = new FileInputStream(file);
```

**Why It's Vulnerable**:

- User input `filename` is concatenated directly into the file path.
- An attacker can use `../` sequences to traverse directories and access unauthorized files.

**Regex Match Explanation**:

- The pattern matches `new File(...)` where the argument includes user input.

### **4.2. Vulnerable Code Example: Using `Files` API with User Input**

```java
String path = request.getParameter("path");
byte[] data = Files.readAllBytes(Paths.get(path));
```

**Why It's Vulnerable**:

- User input `path` is used directly in `Paths.get()`.
- Allows attackers to specify arbitrary paths, potentially accessing sensitive files.

**Regex Match Explanation**:

- The regex detects `Files.readAllBytes(...)` with parameters that may include user input.

### **4.3. Vulnerable Code Example: Resource Loading with User Input**

```java
String resource = request.getParameter("resource");
InputStream is = getClass().getResourceAsStream(resource);
```

**Why It's Vulnerable**:

- User input `resource` is used to load resources.
- Attackers can exploit this to load unauthorized resources or files.

**Regex Match Explanation**:

- The pattern finds `getResourceAsStream(...)` with potentially unsafe parameters.

### **4.4. Vulnerable Code Example: File Upload Handling Without Validation**

```java
Part filePart = request.getPart("file");
String fileName = filePart.getSubmittedFileName();
filePart.write("/uploads/" + fileName);
```

**Why It's Vulnerable**:

- User-controlled `fileName` is used to write the uploaded file.
- Attackers can manipulate `fileName` to overwrite critical files.

**Regex Match Explanation**:

- The regex identifies `request.getPart(...)` and subsequent file operations.

### **4.5. Vulnerable Code Example: Using Environment Variables**

```java
String configPath = System.getenv("CONFIG_PATH");
File configFile = new File(configPath);
FileReader fr = new FileReader(configFile);
```

**Why It's Vulnerable**:

- `CONFIG_PATH` environment variable can be manipulated to point to sensitive files.
- If not properly secured, attackers can set environment variables.

**Regex Match Explanation**:

- The pattern detects `System.getenv(...)` calls.

---

<a name="interpreting-findings"></a>
## **5. Interpreting and Validating Findings**

- **Verify User Input Sources**: Determine if the file paths are constructed using untrusted input sources like `request.getParameter()`, `request.getHeader()`, or form data.
- **Check for Path Manipulation**: Look for the use of `../` or similar sequences in user input that could alter the intended file path.
- **Review File Access Permissions**: Assess whether the application has access to sensitive directories or files that should be restricted.
- **Understand the File Operations**: Identify whether the file operations involve reading, writing, deleting, or listing files, and the potential impact.

**Example**:

- If `filename` is derived from a fixed set of allowed values or sanitized to remove dangerous characters, the risk is lower.
- If user input is used directly without validation, it's a significant vulnerability.

---

<a name="prevention"></a>
## **6. Best Practices for Prevention**

### **6.1. Validate and Sanitize User Input**

- **Canonicalization**: Resolve the absolute path and ensure it remains within a designated directory.

**Example**:

```java
String filename = request.getParameter("filename");
File baseDir = new File("/var/www/uploads/");
File file = new File(baseDir, filename);
String canonicalPath = file.getCanonicalPath();

if (!canonicalPath.startsWith(baseDir.getCanonicalPath())) {
    throw new SecurityException("Invalid file path");
}

FileInputStream fis = new FileInputStream(file);
```

- **Explanation**: This ensures that the resolved path is within the allowed directory.

### **6.2. Use Whitelisting**

- **Allowed Filenames**: Maintain a list of valid filenames or patterns.

**Example**:

```java
Set<String> allowedFiles = Set.of("document.pdf", "image.jpg");
String filename = request.getParameter("filename");

if (!allowedFiles.contains(filename)) {
    throw new SecurityException("Invalid file");
}

File file = new File("/var/www/uploads/", filename);
FileInputStream fis = new FileInputStream(file);
```

### **6.3. Restrict File Permissions**

- **Least Privilege**: Run the application with minimal permissions necessary.
- **File Access Controls**: Ensure the application cannot access sensitive directories.

### **6.4. Avoid Direct Use of User Input in File Paths**

- **Use Indirect References**: Map user inputs to file paths internally.

**Example**:

```java
Map<String, String> fileMap = Map.of(
    "userGuide", "/files/user_guide.pdf",
    "terms", "/files/terms_and_conditions.pdf"
);

String fileKey = request.getParameter("fileKey");
String filePath = fileMap.get(fileKey);

if (filePath == null) {
    throw new SecurityException("Invalid file key");
}

File file = new File(filePath);
FileInputStream fis = new FileInputStream(file);
```

### **6.5. Normalize Paths**

- **Normalize Input Paths**: Use path normalization to eliminate `../` sequences.

**Example**:

```java
String filename = request.getParameter("filename");
String normalized = Paths.get(filename).normalize().toString();

if (normalized.contains("..")) {
    throw new SecurityException("Invalid path");
}

File file = new File("/var/www/uploads/", normalized);
FileInputStream fis = new FileInputStream(file);
```