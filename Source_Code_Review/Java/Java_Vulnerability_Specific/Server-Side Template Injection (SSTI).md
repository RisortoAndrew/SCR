## **1. Introduction to Server-Side Template Injection (SSTI)**

### **1.1. Overview of SSTI**

**Server-Side Template Injection (SSTI)** is a security vulnerability that occurs when user input is concatenated or directly interpolated into server-side templates without proper validation or sanitization. This allows an attacker to inject malicious template expressions, potentially leading to remote code execution, data leakage, or other attacks.

**Key Concepts:**

- **Template Engines:** Tools that allow dynamic generation of web pages by embedding code or expressions within templates. Common Java template engines include JSP, Thymeleaf, FreeMarker, Velocity, and Mustache.
- **Template Expressions:** Placeholders within templates that are evaluated and replaced with dynamic content during rendering.
- **Expression Language (EL):** A language used within templates to access data, manipulate variables, and perform logic.

**Consequences of SSTI Include:**

- **Remote Code Execution (RCE):** Execution of arbitrary code on the server.
- **Data Exposure:** Access to sensitive data on the server.
- **Denial of Service (DoS):** Overloading the server with resource-intensive operations.
- **Security Bypass:** Circumventing authentication or authorization mechanisms.

### **1.2. Why SSTI Occurs**

SSTI occurs when:

- **Untrusted User Input:** User-supplied data is embedded into templates without proper sanitization.
- **Dynamic Template Generation:** Templates are generated or modified at runtime based on user input.
- **Misconfiguration:** Template engines are configured insecurely, exposing internal functionalities.

---

<a name="vulnerable-patterns"></a>
## **2. Common Vulnerable Patterns in Java**

Vulnerabilities arise when developers mishandle user input in relation to template rendering.

### **2.1. Directly Embedding User Input in Templates**

- **String Concatenation:** Building templates by concatenating user input into template strings.
- **Unvalidated Template Parameters:** Passing user input directly as parameters to the template engine.

### **2.2. Using Unsecured Template Engines**

- **Enabling Insecure Features:** Allowing unrestricted access to expression language features.
- **Improper Configuration:** Failing to disable dangerous functionalities.

### **2.3. Dynamic Template Execution**

- **Runtime Compilation:** Compiling and executing templates based on user input.
- **Custom Template Parsers:** Implementing custom logic that processes user input as templates.

### **2.4. Misuse of Expression Language**

- **EL Injection:** User input is evaluated as part of the expression language.
- **Access to Internal Objects:** Allowing access to system classes, methods, or properties.

### **2.5. Lack of Input Validation and Output Encoding**

- **No Validation:** Accepting user input without checking for malicious content.
- **No Encoding:** Rendering user input without proper encoding to neutralize special characters.

---

<a name="detection-methods"></a>
## **3. Regex Patterns and Manual Methods for Detection**

Since you have no access to automated tools, manually inspect your Java code using the following patterns and methods.

### **3.1. Identifying Template Engine Usage**

**Pattern:**

```java
import\s+org\.thymeleaf\..*
import\s+freemarker\..*
import\s+org\.apache\.velocity\..*
import\s+com\.github\.mustachejava\..*
```

**Explanation:**

- Identifies imports from common Java template engines like Thymeleaf, FreeMarker, Velocity, and Mustache.
- Focus your review on code that interacts with these engines.

### **3.2. Detecting Direct Inclusion of User Input in Templates**

**Pattern:**

```java
templateEngine\.process\s*\(.*,\s*context\)
```

- **Check if `context` contains unvalidated user input.

**Alternative Pattern:**

```java
context\.setVariable\s*\(\s*".*"\s*,\s*request\.getParameter\s*\(.*\)\s*\)
```

**Explanation:**

- Finds where user input is set as variables in the template context.
- Verify if user input is properly validated or sanitized before use.

### **3.3. Searching for String Concatenation in Template Names or Content**

**Pattern:**

```java
String\s+templateName\s*=\s*".*"\s*\+\s*request\.getParameter\s*\(.*\)
```

**Explanation:**

- Detects template names being dynamically constructed using user input.
- Review such usages for potential SSTI vulnerabilities.

### **3.4. Identifying Use of `eval`, `exec`, or Similar Methods in Templates**

**Pattern:**

```java
.*\b(eval|exec|execute)\b.*
```

**Explanation:**

- Finds code that uses dangerous methods that may execute arbitrary code.
- Look for such methods in custom template logic or script evaluations.

### **3.5. Checking for Unescaped Output in Templates**

**In Template Files:**

- Look for expressions that output variables without proper escaping.

**Thymeleaf Example:**

```html
[[${userInput}]]
```

- Instead of the safe:

```html
[[|${userInput}|]]
```

**FreeMarker Example:**

```ftl
${userInput}
```

- Instead of using:

```ftl
${userInput?html}
```

**Explanation:**

- Unescaped output may allow injected expressions to be evaluated.

### **3.6. Searching for Misconfigured Template Engine Settings**

**Pattern:**

- For Thymeleaf:

  ```java
  templateEngine\.setEnableSpringELCompiler\s*\(\s*true\s*\)
  ```

- For FreeMarker:

  ```java
  cfg\.setNewBuiltinClassResolver\s*\(\s*TemplateClassResolver\.UNRESTRICTED_RESOLVER\s*\)
  ```

**Explanation:**

- Identifies configurations that may enable unsafe features.
- Ensure that secure settings are applied.

### **3.7. Detecting Custom Template Parsers**

**Pattern:**

```java
public\s+class\s+\w+\s+implements\s+TemplateParser
```

**Explanation:**

- Finds custom template parsers that may process user input.
- Review the implementation for secure handling of input.

### **3.8. Identifying Dynamic Compilation or Execution**

**Pattern:**

```java
JavaCompiler\s+compiler\s*=\s*ToolProvider\.getSystemJavaCompiler\s*\(\s*\)
```

**Explanation:**

- Detects code that compiles and executes code at runtime.
- Assess if user input influences the code being compiled.

---

<a name="examples"></a>
## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: Directly Embedding User Input**

**Java Controller:**

```java
@GetMapping("/welcome")
public String welcome(Model model, @RequestParam("name") String name) {
    model.addAttribute("message", "Welcome " + name);
    return "welcome";
}
```

**Thymeleaf Template (`welcome.html`):**

```html
<html>
<body>
    <p th:utext="${message}"></p>
</body>
</html>
```

**Why It's Vulnerable:**

- **Use of `th:utext`:** This attribute outputs unescaped text, allowing HTML and expressions to be interpreted.
- **Direct Concatenation:** User input (`name`) is concatenated without validation or encoding.
- **Potential Attack:**
  - An attacker can input `${T(java.lang.Runtime).getRuntime().exec('calc')}`, leading to code execution.

**Regex Match Explanation:**

- The pattern identifies the use of `th:utext` and direct inclusion of `name` without validation.

### **4.2. Vulnerable Code Example: Unvalidated Template Parameters**

**Java Code Using FreeMarker:**

```java
Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);
Template template = cfg.getTemplate("templates/" + request.getParameter("templateName"));
template.process(dataModel, writer);
```

**Why It's Vulnerable:**

- **Dynamic Template Selection:** The template name is taken directly from user input.
- **Potential Attack:**
  - An attacker can specify a template that includes malicious code or access unauthorized templates.

**Regex Match Explanation:**

- The pattern matches `getTemplate("templates/" + request.getParameter("templateName"))`.

### **4.3. Vulnerable Code Example: EL Injection**

**JSP Code:**

```jsp
<%
    String userInput = request.getParameter("input");
    session.setAttribute("data", userInput);
%>
${sessionScope.data}
```

**Why It's Vulnerable:**

- **EL Evaluation of User Input:** The user input is stored in the session and then evaluated by the EL expression.
- **Potential Attack:**
  - An attacker can input `${request.getSession().invalidate()}` to manipulate the session.

**Regex Match Explanation:**

- The code shows `${sessionScope.data}` where `data` comes from unvalidated user input.

### **4.4. Vulnerable Code Example: Misconfigured Template Engine**

**Java Code Using FreeMarker:**

```java
cfg.setNewBuiltinClassResolver(TemplateClassResolver.UNRESTRICTED_RESOLVER);
```

**Why It's Vulnerable:**

- **Unrestricted Access:** Allows templates to access any class, including system classes.
- **Potential Attack:**
  - An attacker can execute arbitrary code via template expressions.

**Regex Match Explanation:**

- Matches `cfg.setNewBuiltinClassResolver(TemplateClassResolver.UNRESTRICTED_RESOLVER)`.

### **4.5. Vulnerable Code Example: Custom Template Parsing with User Input**

**Java Code:**

```java
public String renderTemplate(String templateContent, Map<String, Object> data) {
    Template template = engine.createTemplate(templateContent);
    StringWriter writer = new StringWriter();
    template.process(data, writer);
    return writer.toString();
}

@PostMapping("/preview")
public String preview(@RequestParam("template") String template, Model model) {
    String result = renderTemplate(template, model.asMap());
    model.addAttribute("preview", result);
    return "preview";
}
```

**Why It's Vulnerable:**

- **User-Controlled Template Content:** The user provides the entire template content.
- **Potential Attack:**
  - An attacker can include malicious template code that gets executed on the server.

**Regex Match Explanation:**

- The method `renderTemplate` uses `templateContent` derived from user input without validation.

---

<a name="interpreting-findings"></a>
## **5. Interpreting and Validating Findings**

When analyzing potential SSTI vulnerabilities:

- **Assess Input Sources:**

  - Identify where user input is accepted.
  - Determine if input is validated or sanitized.

- **Review Template Rendering:**

  - Check how templates are rendered and where user input is included.
  - Look for unescaped or unencoded output.

- **Evaluate Template Engine Configurations:**

  - Ensure secure settings are enabled.
  - Verify that dangerous features are disabled.

- **Understand the Context:**

  - Consider how the application uses templates.
  - Assess the potential impact of injected expressions.

- **Consider Abuse Cases:**

  - Think about how an attacker might manipulate inputs to exploit the vulnerability.

**Example Validation:**

- In the `welcome` method, verify if the use of `th:utext` is necessary and if user input (`name`) can be safely included without encoding.

---

<a name="prevention"></a>
## **6. Best Practices for Prevention**

### **6.1. Validate and Sanitize User Input**

- **Input Validation:**

  - Implement whitelisting to accept only expected input formats.
  - Reject inputs containing malicious patterns or special characters.

- **Example:**

  ```java
  String name = request.getParameter("name");
  if (!name.matches("^[a-zA-Z\\s]{1,50}$")) {
      throw new IllegalArgumentException("Invalid name");
  }
  ```

### **6.2. Use Safe Rendering Methods**

- **Escape Output:**

  - Use encoding functions or safe output methods provided by the template engine.

- **Thymeleaf Example:**

  - Use `th:text` instead of `th:utext`.

    ```html
    <p th:text="${message}"></p>
    ```

- **FreeMarker Example:**

  - Apply appropriate built-in escapes.

    ```ftl
    ${userInput?html}
    ```

### **6.3. Avoid Direct Inclusion of User Input in Templates**

- **Do Not Allow Users to Control Template Content or Names:**

  - Templates should be selected from a predefined set.
  - Do not construct template paths using user input.

- **Example:**

  ```java
  String templateName = "defaultTemplate";
  if ("welcome".equals(request.getParameter("templateName"))) {
      templateName = "welcomeTemplate";
  }
  Template template = cfg.getTemplate(templateName);
  ```

### **6.4. Secure Template Engine Configurations**

- **Disable Dangerous Features:**

  - For FreeMarker:

    ```java
    cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);
    ```

  - For Thymeleaf:

    - Do not enable Spring EL compiler unless necessary.

- **Restrict Access:**

  - Limit the template engine's ability to access system classes or execute code.

### **6.5. Implement Content Security Policy (CSP)**

- **Configure CSP Headers:**

  - Use CSP to mitigate the impact of injected scripts.

- **Example:**

  ```java
  response.setHeader("Content-Security-Policy", "default-src 'self'");
  ```

### **6.6. Perform Output Encoding**

- **Apply Encoding:**

  - Encode user input before including it in templates.

- **Example:**

  ```java
  String safeInput = StringEscapeUtils.escapeHtml4(userInput);
  model.addAttribute("userInput", safeInput);
  ```