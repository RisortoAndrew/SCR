## **1. Introduction to Insecure Deserialization**

**Insecure Deserialization** is a critical security vulnerability that occurs when an application deserializes untrusted or tampered data without proper validation. This can lead to severe consequences, including arbitrary code execution, denial of service, authentication bypass, and more.

In Java applications, serialization is commonly used to convert objects into a format that can be stored or transmitted and then reconstructed later. However, deserializing data from untrusted sources can be dangerous if not handled securely.

---

<a name="vulnerable-patterns"></a>
## **2. Common Vulnerable Patterns in Java**

Vulnerable patterns in Java applications that can lead to insecure deserialization include:

- **Using Java's Native Serialization Mechanism (`ObjectInputStream`)**: Deserializing objects without validating the source.
- **Deserializing Untrusted Data**: Accepting serialized objects from untrusted sources like network input, files, or HTTP requests.
- **Third-Party Libraries**: Using libraries that perform deserialization internally without proper security measures.
- **Custom Deserialization Logic**: Implementing custom deserialization methods (`readObject`, `readResolve`) that can be exploited.
- **Lack of Input Validation and Sanitization**: Not verifying the integrity or origin of serialized data.

---

<a name="regex-patterns"></a>
## **3. Regex Patterns for Detection**

Below are regex patterns designed to identify potential insecure deserialization points in Java code. These patterns can be used in VS Code's global search functionality.

### **3.1. Usage of `ObjectInputStream`**

**Pattern**:

```regex
new\s+ObjectInputStream\s*\(\s*(.*)\s*\)
```

**Explanation**:

- Detects instances where `ObjectInputStream` is instantiated.
- Captures the input stream being used.

### **3.2. Calls to `readObject` or `readUnshared`**

**Pattern**:

```regex
(\w+\s*=\s*)?\w+\.read(Object|Unshared)\s*\(
```

**Explanation**:

- Finds calls to `readObject()` or `readUnshared()` methods.
- Indicates where deserialization occurs.

### **3.3. Usage of Apache Commons `SerializationUtils`**

**Pattern**:

```regex
SerializationUtils\.(deserialize|clone)\s*\(
```

**Explanation**:

- Detects usage of `SerializationUtils.deserialize()` and `SerializationUtils.clone()` methods, which perform deserialization.

### **3.4. Custom Deserialization Methods**

**Pattern**:

```regex
private\s+void\s+readObject\s*\(\s*ObjectInputStream\s+\w+\s*\)\s*throws
```

**Explanation**:

- Identifies custom `readObject()` methods in classes, which can be entry points for deserialization exploits.

### **3.5. XML Deserialization (e.g., XStream)**

**Pattern**:

```regex
new\s+XStream\s*\(\s*\)
```

**Explanation**:

- Detects instantiation of XStream, which can be vulnerable if not configured securely.

### **3.6. JSON Deserialization with Untrusted Data**

**Pattern**:

```regex
new\s+ObjectMapper\s*\(\s*\)
```

**Explanation**:

- Finds instances where Jackson's `ObjectMapper` is used, potentially deserializing untrusted JSON data.

---

<a name="examples"></a>
## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: Using `ObjectInputStream` with Untrusted Data**

```java
InputStream is = request.getInputStream();
ObjectInputStream ois = new ObjectInputStream(is);
Object obj = ois.readObject();
```

**Why It's Vulnerable**:

- The application reads serialized data directly from the HTTP request.
- An attacker can send a malicious serialized object that, when deserialized, can execute arbitrary code.

**Regex Match Explanation**:

- The regex matches the instantiation of `ObjectInputStream` and the call to `readObject()`.

### **4.2. Vulnerable Code Example: Deserialization via Apache Commons**

```java
byte[] data = request.getParameter("data").getBytes();
Object obj = SerializationUtils.deserialize(data);
```

**Why It's Vulnerable**:

- Deserializes data directly from user input without validation.
- Apache Commons `SerializationUtils.deserialize()` is used, which can be exploited.

**Regex Match Explanation**:

- The pattern detects the use of `SerializationUtils.deserialize()`.

### **4.3. Vulnerable Code Example: Custom `readObject` Method**

```java
public class User implements Serializable {
    private String username;
    private String password;

    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject();
        // Custom deserialization logic
    }
}
```

**Why It's Vulnerable**:

- Custom `readObject()` methods can be overridden to include malicious code.
- If untrusted data is deserialized into this class, the custom method may be exploited.

**Regex Match Explanation**:

- The regex finds the custom `readObject()` method declaration.

### **4.4. Vulnerable Code Example: XML Deserialization with XStream**

```java
XStream xstream = new XStream();
Object obj = xstream.fromXML(request.getParameter("xmlData"));
```

**Why It's Vulnerable**:

- XStream can deserialize XML into objects, potentially leading to remote code execution if not properly secured.
- User input `xmlData` is deserialized without validation.

**Regex Match Explanation**:

- The pattern matches the instantiation of `XStream` and usage of `fromXML()`.

### **4.5. Vulnerable Code Example: JSON Deserialization with Jackson**

```java
ObjectMapper mapper = new ObjectMapper();
User user = mapper.readValue(request.getParameter("jsonData"), User.class);
```

**Why It's Vulnerable**:

- Jackson can deserialize JSON into objects, and if certain features are enabled, it can be exploited.
- Deserializing untrusted data without secure configuration.

**Regex Match Explanation**:

- The regex finds instantiations of `ObjectMapper`, indicating potential deserialization points.

---

<a name="interpreting-findings"></a>
## **5. Interpreting and Validating Findings**

- **Confirm the Source of Data**: Determine if the data being deserialized comes from an untrusted source (e.g., user input, network, files).
- **Review Configuration**: Check if the deserialization libraries are configured securely (e.g., type whitelisting, disabling certain features).
- **Understand the Data Flow**: Trace how the data flows into the deserialization methods.

**Example**:

- If `ObjectInputStream` is used to deserialize data from a trusted, internal source (e.g., a secured database), the risk may be minimal.
- If the source is untrusted or can be tampered with, it's a significant vulnerability.

---

<a name="prevention"></a>
## **6. Best Practices for Prevention**

### **6.1. Avoid Deserializing Untrusted Data**

- **Recommendation**: Do not accept serialized objects from untrusted sources.
- **Alternative**: Use safer data formats like JSON or XML with strict parsing.

### **6.2. Implement Integrity Checks**

- **Digital Signatures**: Sign serialized data and verify the signature before deserialization.
- **Checksum Validation**: Use checksums to detect tampering.

### **6.3. Use Object Input Validation**

- **Validation**: Implement validation logic to ensure only expected classes are deserialized.
- **Whitelisting**: Use a whitelist of acceptable classes during deserialization.

**Example with `ObjectInputStream` Subclass**:

```java
public class ValidatingObjectInputStream extends ObjectInputStream {
    private static final Set<String> ALLOWED_CLASSES = Set.of("com.example.MyClass");

    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
        if (!ALLOWED_CLASSES.contains(desc.getName())) {
            throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
        }
        return super.resolveClass(desc);
    }
}
```

### **6.4. Secure Configuration of Libraries**

- **For XStream**:

  ```java
  XStream xstream = new XStream();
  xstream.addPermission(NoTypePermission.NONE);
  xstream.allowTypesByWildcard(new String[] {
      "com.example.models.**"
  });
  ```

- **For Jackson**:

  - Disable default typing:

    ```java
    ObjectMapper mapper = new ObjectMapper();
    mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
    mapper.activateDefaultTyping(
        LaissezFaireSubTypeValidator.instance,
        ObjectMapper.DefaultTyping.NON_FINAL
    );
    ```

  - **Note**: Be cautious with default typing; ensure that only trusted types are allowed.

### **6.5. Use Serialization Proxies**

- Implement serialization proxies to control the serialization and deserialization process.

**Example**:

```java
public final class SafeObject implements Serializable {
    private String data;

    private Object writeReplace() {
        return new SafeObjectProxy(this);
    }

    private static class SafeObjectProxy implements Serializable {
        private String data;

        SafeObjectProxy(SafeObject obj) {
            this.data = obj.data;
        }

        private Object readResolve() {
            return new SafeObject(data);
        }
    }
}
```