## **1. Introduction to HTTP Request Smuggling**

**HTTP Request Smuggling** is a web application vulnerability that occurs when a server or a chain of servers (e.g., proxies, load balancers, and web servers) interpret ambiguous HTTP requests differently. Attackers exploit these inconsistencies to "smuggle" a malicious request to the backend server without the frontend server being aware of it.

**Consequences of HTTP Request Smuggling include:**

- **Session Hijacking:** Intercepting or manipulating legitimate user requests.
- **Cache Poisoning:** Inserting malicious content into the cache.
- **Cross-Site Scripting (XSS):** Injecting scripts that run in users' browsers.
- **Information Disclosure:** Gaining access to sensitive data.
- **Denial of Service (DoS):** Disrupting the normal operation of services.

**Key concepts:**

- **HTTP Headers Involved:**
  - `Content-Length`: Specifies the size of the request body in bytes.
  - `Transfer-Encoding`: Specifies the type of encoding used on the body, e.g., `chunked`.

- **Types of HTTP Request Smuggling Attacks:**
  - **CL.TE (Content-Length vs. Transfer-Encoding):** Frontend uses `Content-Length`, backend uses `Transfer-Encoding`.
  - **TE.CL:** Frontend uses `Transfer-Encoding`, backend uses `Content-Length`.
  - **TE.TE:** Mismatches in `Transfer-Encoding` handling between servers.
  - **HTTP/2 to HTTP/1.1 Downgrade:** Issues when converting HTTP/2 requests to HTTP/1.1.

Identifying and mitigating HTTP Request Smuggling vulnerabilities is essential to protect the integrity and security of web applications.

---

<a name="vulnerable-patterns"></a>
## **2. Common Vulnerable Patterns in Java**

Vulnerable patterns in Java applications related to HTTP Request Smuggling include:

- **Inconsistent Parsing of HTTP Requests:**
  - Custom parsers or modifications to request handling that deviate from standard behavior.
- **Use of Legacy Libraries or Servers:**
  - Outdated or unpatched versions of web servers (e.g., Apache Tomcat) that are known to be vulnerable.
- **Improper Configuration of Proxies and Load Balancers:**
  - Misconfigurations that lead to inconsistent handling of `Content-Length` and `Transfer-Encoding` headers.
- **Lack of Input Validation:**
  - Accepting and processing malformed or ambiguous HTTP requests without validation.
- **Custom Middleware or Filters:**
  - Implementing custom filters that modify request headers or bodies in a way that introduces inconsistencies.
- **Disabled Security Features:**
  - Turning off features that protect against HTTP Request Smuggling, such as strict header validation.
- **Use of Non-Standard HTTP Methods:**
  - Accepting methods that may not be properly handled by all components in the request chain.

---

<a name="http-headers"></a>
## **3. Understanding HTTP Headers and Configurations**

Before proceeding to detection methods, it's important to understand how HTTP headers are used in requests and how servers interpret them.

### **3.1. Content-Length Header**

- Specifies the exact byte length of the HTTP request body.
- Used by servers to determine where the request ends.

### **3.2. Transfer-Encoding Header**

- Indicates that the message body is encoded using a certain encoding (e.g., `chunked`).
- In `chunked` encoding, the body is sent in a series of chunks, each with its own size indicator.

### **3.3. HTTP/1.1 vs. HTTP/1.0**

- **HTTP/1.1** supports `Transfer-Encoding` and persistent connections by default.
- **HTTP/1.0** does not support `Transfer-Encoding`.

### **3.4. Server Behavior**

- **Front-End Server (Proxy/Load Balancer):** May interpret headers differently than the back-end server.
- **Back-End Server (Application Server):** May process requests differently based on its configuration.

---

<a name="detection-methods"></a>
## **4. Manual Methods for Detection**

Since you have no access to automated tools, manual inspection of server configurations and code is essential.

### **4.1. Reviewing Server Configurations**

- **Apache Tomcat, Jetty, etc.:** Check for configurations related to HTTP header parsing.
- **Proxy Servers and Load Balancers:** Inspect configurations for handling of `Content-Length` and `Transfer-Encoding` headers.

### **4.2. Inspecting Custom Request Parsing Code**

- **Custom Parsers:** Look for code that manually parses HTTP requests.
- **Filters and Interceptors:** Review any custom `Filter` or `Interceptor` implementations.

### **4.3. Analyzing Middleware and Frameworks**

- **Frameworks Used:** Determine if the frameworks are up-to-date and properly configured.
- **Middleware Configurations:** Inspect middleware that might alter request headers or bodies.

### **4.4. Checking for Disabled Security Features**

- **Lenient Parsing Settings:** Look for configurations that relax standard parsing rules.
- **Disabled Validations:** Identify any code that disables header validation or error handling.

### **4.5. Understanding the Request Flow**

- **Request Chain:** Map out how requests flow from the client to the backend server.
- **Components Involved:** Identify all intermediaries (e.g., proxies, firewalls, WAFs).

### **4.6. Reviewing Logs**

- **Error Logs:** Look for anomalies or errors related to request parsing.
- **Access Logs:** Check for unusual patterns that might indicate exploitation attempts.

---

<a name="examples"></a>
## **5. Detailed Examples and Explanations**

### **5.1. Vulnerable Configuration Example: Lenient HTTP Header Parsing**

**Server Configuration (Tomcat `server.xml`):**

```xml
<Connector port="8080" protocol="HTTP/1.1"
           maxHttpHeaderSize="8192"
           relaxedQueryChars="[]|"
           relaxedPathChars="[]|"
           allowHttpRequestParserErrors="true" />
```

**Why It's Vulnerable:**

- **`allowHttpRequestParserErrors="true"`:**
  - Allows the server to accept requests with parsing errors.
  - May lead to inconsistent request interpretation.

- **`relaxedQueryChars` and `relaxedPathChars`:**
  - Permits non-standard characters in URLs.
  - Can be exploited to smuggle requests.

### **5.2. Vulnerable Code Example: Custom HTTP Request Parsing**

```java
public class CustomHttpRequestParser {

    public HttpRequest parse(InputStream inputStream) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        String initialLine = reader.readLine();
        // Custom parsing logic
        // ...

        String headerLine;
        while (!(headerLine = reader.readLine()).isEmpty()) {
            // Process headers
            // Does not properly handle multiple Content-Length or Transfer-Encoding headers
        }
        // Continue processing
        return httpRequest;
    }
}
```

**Why It's Vulnerable:**

- **Improper Header Handling:**
  - Does not enforce single occurrence of `Content-Length` or `Transfer-Encoding`.
  - May accept requests with conflicting headers.

- **Custom Parsing Logic:**
  - Deviates from standard parsing behavior.
  - Increases risk of inconsistencies.

### **5.3. Vulnerable Code Example: Accepting Non-Standard HTTP Methods**

```java
@WebServlet("/process")
public class ProcessServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // Accepts any HTTP method
        // Processes requests without validation
        // ...
    }
}
```

**Why It's Vulnerable:**

- **`service()` Method Override:**
  - Directly handles all HTTP methods.
  - May process unexpected methods not properly handled by intermediaries.

- **Lack of Validation:**
  - Does not verify request method or headers.
  - Increases risk of smuggled requests.

### **5.4. Vulnerable Configuration Example: Misconfigured Proxy**

**Proxy Configuration (e.g., Nginx):**

```nginx
server {
    listen 80;

    location / {
        proxy_pass http://backend_server;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }
}
```

**Why It's Vulnerable:**

- **`proxy_http_version 1.1;`:**
  - Uses HTTP/1.1 but may not properly handle `Transfer-Encoding`.

- **Missing Header Sanitization:**
  - Does not remove or normalize `Content-Length` and `Transfer-Encoding` headers.
  - Backend server may interpret headers differently.

---

<a name="interpreting-findings"></a>
## **6. Interpreting and Validating Findings**

- **Identify Discrepancies:**
  - Look for inconsistencies between how different components handle HTTP requests.

- **Understand Parsing Behavior:**
  - Know how the frontend and backend servers parse `Content-Length` and `Transfer-Encoding` headers.

- **Check for Multiple Header Handling:**
  - Verify that the server rejects requests with multiple `Content-Length` or conflicting headers.

- **Assess Custom Code:**
  - Review custom parsers or filters for adherence to RFC specifications.

- **Evaluate Server Versions:**
  - Ensure that servers and libraries are up-to-date with security patches.

- **Consider the Entire Request Chain:**
  - Understand how proxies, load balancers, and application servers interact.

**Example:**

- If a proxy server uses `Content-Length` to determine request boundaries but the backend server uses `Transfer-Encoding`, an attacker might exploit this to smuggle requests.

---

<a name="prevention"></a>
## **7. Best Practices for Prevention**

### **7.1. Use Up-to-Date Servers and Libraries**

- **Keep Software Updated:**
  - Regularly update web servers, proxies, and libraries to the latest versions with security patches.

### **7.2. Enforce Strict HTTP Parsing**

- **Disable Lenient Parsing:**
  - Configure servers to reject malformed or ambiguous requests.

**Example for Apache Tomcat:**

```xml
<Connector port="8080" protocol="HTTP/1.1"
           allowHttpRequestParserErrors="false" />
```

### **7.3. Normalize or Remove Ambiguous Headers**

- **Sanitize Headers:**
  - Ensure that only one of `Content-Length` or `Transfer-Encoding` is accepted.
  - Remove or normalize conflicting headers at the edge of the network.

**Example in Nginx:**

```nginx
proxy_set_header Transfer-Encoding "";
```

### **7.4. Consistent HTTP Versions**

- **Align HTTP Protocols:**
  - Use the same HTTP protocol versions across all components.
  - Avoid downgrading from HTTP/2 to HTTP/1.1 if possible.

### **7.5. Validate Input Thoroughly**

- **Reject Malformed Requests:**
  - Implement validation to reject requests with:
    - Multiple `Content-Length` headers.
    - Conflicting `Content-Length` and `Transfer-Encoding` headers.
    - Invalid header values.

### **7.6. Proper Error Handling**

- **Respond with Appropriate Status Codes:**
  - Return `400 Bad Request` for malformed requests.
  - Do not reveal internal processing details.

### **7.7. Limit Request Sizes**

- **Set Maximum Request Limits:**
  - Configure maximum header and body sizes to prevent buffer overflows.

**Example for Apache Tomcat:**

```xml
<Connector port="8080" protocol="HTTP/1.1"
           maxHttpHeaderSize="8192"
           maxPostSize="2097152" />
```
