## **1. Introduction to SQL Injection**

**SQL Injection** is a critical security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. It occurs when untrusted input is concatenated into SQL statements without proper validation or parameterization, potentially allowing attackers to execute arbitrary SQL code.

---

<a name="vulnerable-patterns"></a>
## **2. Common Vulnerable Patterns in Java**

In Java applications, particularly those using JDBC or frameworks like Spring JDBC, vulnerabilities often arise due to:

- **String Concatenation**: Building SQL queries by concatenating strings with user input.
- **Dynamic Query Construction**: Using user input directly in query construction without proper sanitization.
- **Improper Use of ORM Queries**: Misusing Object-Relational Mapping (ORM) tools like Hibernate.

---

<a name="regex-patterns"></a>
## **3. Regex Patterns for Detection**

Below are regex patterns designed to identify potential SQL Injection points in Java code. These can be used in VS Code's global search functionality.

### **3.1. String Concatenation in SQL Statements**

**Pattern**:

```regex
("|\+)\s*\+\s*(request\.getParameter|session\.getAttribute|[^;]+)\s*\+\s*("|\+)
```

**Explanation**:

- Looks for concatenations in strings, specifically around SQL statements.
- Detects user input methods like `request.getParameter()`.

### **3.2. Usage of `Statement` Instead of `PreparedStatement`**

**Pattern**:

```regex
\bStatement\b\s+\w+\s*=
```

**Explanation**:

- Identifies instances where `Statement` is used, which is vulnerable compared to `PreparedStatement`.

### **3.3. Execution of Dynamic Queries**

**Pattern**:

```regex
execute(Query|Update)\s*\(.*(\+|String\.format)
```

**Explanation**:

- Finds `executeQuery` or `executeUpdate` methods with dynamic query construction.

### **3.4. ORM Vulnerabilities**

**Pattern**:

```regex
createQuery\s*\(.*\+\s*(request\.getParameter|session\.getAttribute)
```

**Explanation**:

- Detects dynamic HQL/JPQL queries built with user input.

### **3.5. JDBC Template without Parameters**

**Pattern**:

```regex
jdbcTemplate\.query(ForObject|ForList)?\s*\(.*(\+|String\.format)
```

**Explanation**:

- Finds uses of Spring's `JdbcTemplate` where queries are built dynamically.

---

<a name="examples"></a>
## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: String Concatenation**

```java
String userId = request.getParameter("userId");
String query = "SELECT * FROM users WHERE id = " + userId;
Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery(query);
```

**Why It's Vulnerable**:

- User input `userId` is directly concatenated into the SQL query.
- An attacker could supply malicious input like `1 OR 1=1` to manipulate the query.

**Regex Match Explanation**:

- The pattern detects the `+` operator used to concatenate `userId` into the query string.

### **4.2. Vulnerable Code Example: Dynamic Query Execution**

```java
String sql = "UPDATE accounts SET balance = " + amount + " WHERE account_id = " + accountId;
stmt.executeUpdate(sql);
```

**Why It's Vulnerable**:

- Both `amount` and `accountId` may come from user input and are concatenated into the SQL statement.
- This allows injection of malicious SQL code.

**Regex Match Explanation**:

- The regex identifies the use of `executeUpdate` with a dynamically built SQL string.

### **4.3. Vulnerable Code Example: ORM Misuse**

```java
String hql = "FROM User WHERE username = '" + username + "'";
List<User> users = session.createQuery(hql).list();
```

**Why It's Vulnerable**:

- User input `username` is used in HQL without parameterization.
- Allows attackers to inject HQL code.

**Regex Match Explanation**:

- The pattern catches `createQuery` methods with string concatenation involving user input.

---

<a name="interpreting-findings"></a>
## **5. Interpreting and Validating Findings**

- **False Positives**: Not all matches indicate a vulnerability. Review the context of each match.
- **User Input Sources**: Pay special attention to input sources like `request.getParameter()`, `request.getHeader()`, `session.getAttribute()`, etc.
- **Data Flow Analysis**: Trace variables back to their sources to determine if they originate from user input.

**Example**:

- If a variable used in a query is derived from a constant or a secure source, it may not be vulnerable.
- Conversely, variables that are influenced by user input need careful examination.

---

<a name="prevention"></a>
## **6. Best Practices for Prevention**

### **6.1. Use Prepared Statements**

**Safe Example**:

```java
String query = "SELECT * FROM users WHERE id = ?";
PreparedStatement pstmt = connection.prepareStatement(query);
pstmt.setInt(1, Integer.parseInt(userId));
ResultSet rs = pstmt.executeQuery();
```

- **Explanation**: `PreparedStatement` uses parameterized queries, preventing SQL Injection.

### **6.2. Input Validation**

- **Sanitize Input**: Validate and sanitize all user inputs.
- **Whitelist Approach**: Accept only expected values and formats.

### **6.3. ORM Parameterization**

**Safe Example**:

```java
String hql = "FROM User WHERE username = :username";
Query query = session.createQuery(hql);
query.setParameter("username", username);
List<User> users = query.list();
```

- **Explanation**: Parameters are set safely using `setParameter`.

### **6.4. Stored Procedures**

- Use stored procedures with parameterized inputs to interact with the database.