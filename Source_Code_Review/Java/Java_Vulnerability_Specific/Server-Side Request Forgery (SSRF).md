## **1. Introduction to Server-Side Request Forgery (SSRF)**

**Server-Side Request Forgery (SSRF)** is a security vulnerability that allows an attacker to induce the server-side application to make HTTP or other network requests to an unintended destination. The attacker can manipulate URLs or request parameters to control where the server makes requests, potentially accessing internal systems, sensitive data, or performing unauthorized actions.

**Consequences of SSRF include**:

- **Bypassing Network Restrictions**: Accessing internal network resources not exposed to the internet.
- **Sensitive Data Exposure**: Retrieving sensitive data from internal services.
- **Remote Code Execution**: In some cases, SSRF can lead to code execution on the server.
- **Port Scanning**: Scanning internal network ports to discover services.
- **Credential Leakage**: Accessing metadata services in cloud environments to obtain credentials.

Identifying and mitigating SSRF vulnerabilities is critical for protecting internal networks and data from unauthorized access.

---

<a name="vulnerable-patterns"></a>
## **2. Common Vulnerable Patterns in Java**

Vulnerable patterns in Java applications that can lead to SSRF include:

- **Direct Use of User Input in Network Requests**: Using user-supplied URLs or hostnames without validation.
- **Downloading Remote Resources Based on User Input**: Fetching images, files, or data from URLs provided by users.
- **Open Redirects Leading to SSRF**: Redirecting server-side requests based on unvalidated user input.
- **DNS Rebinding Attacks**: Using hostnames that resolve to internal IP addresses after initial validation.
- **Use of Legacy Protocols**: Accepting URLs with protocols like `file://`, `ftp://`, or `gopher://` that can be exploited.
- **Blind SSRF via Error Messages**: Error messages revealing network details when requests fail.
- **SSRF in Deserialization**: Deserializing user input that contains references to external resources.
- **Server-Side Includes (SSI)**: Including files or resources based on user input.

---

<a name="regex-patterns"></a>
## **3. Regex Patterns for Detection**

Below are regex patterns designed to identify potential SSRF vulnerabilities in Java code. Since you have no access to automated tools, you can use these patterns in your IDE's global search functionality to manually search the codebase.

### **3.1. Usage of `HttpURLConnection` with User Input**

**Pattern**:

```regex
new\s+URL\s*\(\s*(.*)\s*\)
```

**Explanation**:

- Detects instantiation of `URL` objects.
- Focus on instances where the argument may include user input.

### **3.2. Usage of Apache HttpClient with User Input**

**Pattern**:

```regex
(new\s+HttpGet\s*\(\s*(.*)\s*\))|(new\s+HttpPost\s*\(\s*(.*)\s*\))
```

**Explanation**:

- Identifies creation of `HttpGet` or `HttpPost` objects with potentially unvalidated URLs.

### **3.3. Usage of `URLConnection` with User Input**

**Pattern**:

```regex
(\w+)\s*=\s*\1\.openConnection\s*\(.*\)
```

**Explanation**:

- Finds calls to `openConnection()` method, which may be invoked on a `URL` object.

### **3.4. Usage of Third-Party Libraries for HTTP Requests**

**Pattern**:

```regex
Jsoup\.connect\s*\(\s*(.*)\s*\)
```

**Explanation**:

- Detects use of the Jsoup library for making HTTP requests with URLs.

### **3.5. Direct Use of `InetAddress.getByName()`**

**Pattern**:

```regex
InetAddress\.getByName\s*\(\s*(.*)\s*\)
```

**Explanation**:

- Identifies code resolving hostnames, potentially leading to DNS rebinding attacks.

### **3.6. Usage of `RestTemplate` in Spring Framework**

**Pattern**:

```regex
restTemplate\.(getForObject|getForEntity|postForObject|postForEntity)\s*\(\s*(.*)\s*,\s*(.*)\s*\)
```

**Explanation**:

- Finds HTTP requests made using Spring's `RestTemplate` with potentially unvalidated URLs.

### **3.7. Handling of URLs from User Input**

**Pattern**:

```regex
String\s+\w+\s*=\s*request\.getParameter\s*\(\s*["'](url|uri|endpoint|path|link)["']\s*\)
```

**Explanation**:

- Captures retrieval of URL-like parameters from user input.

### **3.8. Use of `RequestDispatcher.include()` or `forward()` with User Input**

**Pattern**:

```regex
request\.getRequestDispatcher\s*\(\s*(.*)\s*\)\.(include|forward)\s*\(.*\)
```

**Explanation**:

- Identifies server-side includes or forwards that may include user-supplied paths.

---

<a name="examples"></a>
## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: Direct Use of User-Supplied URL**

```java
String imageUrl = request.getParameter("imageUrl");
URL url = new URL(imageUrl);
InputStream is = url.openStream();
// Process the input stream
```

**Why It's Vulnerable**:

- The `imageUrl` parameter is taken directly from user input.
- No validation is performed on `imageUrl`.
- An attacker can supply a URL pointing to internal resources or malicious sites.
- Can lead to unauthorized access to internal services or data.

**Regex Match Explanation**:

- The regex matches `new URL(imageUrl)`, where `imageUrl` may include user input.

### **4.2. Vulnerable Code Example: Using `HttpClient` with User Input**

```java
String apiEndpoint = request.getParameter("apiEndpoint");
HttpClient client = HttpClientBuilder.create().build();
HttpGet request = new HttpGet(apiEndpoint);
HttpResponse response = client.execute(request);
// Process the response
```

**Why It's Vulnerable**:

- `apiEndpoint` is derived from user input without validation.
- Attackers can force the server to make requests to arbitrary URLs.
- Potential to access internal APIs or services.

**Regex Match Explanation**:

- The regex detects `new HttpGet(apiEndpoint)` with `apiEndpoint` possibly coming from user input.

### **4.3. Vulnerable Code Example: Using `RestTemplate` with Unvalidated URL**

```java
String url = request.getParameter("url");
ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
// Process the response
```

**Why It's Vulnerable**:

- `url` is taken directly from user input.
- Allows attackers to control the destination of the server's HTTP request.
- Can be exploited to access internal services or perform port scans.

**Regex Match Explanation**:

- The regex matches `restTemplate.getForEntity(url, String.class)`.

### **4.4. Vulnerable Code Example: Using `InetAddress.getByName()` with User Input**

```java
String hostname = request.getParameter("hostname");
InetAddress address = InetAddress.getByName(hostname);
// Use the address for some operation
```

**Why It's Vulnerable**:

- `hostname` is from user input without validation.
- Can be exploited via DNS rebinding to access internal IP addresses.
- May reveal internal network structure.

**Regex Match Explanation**:

- The regex identifies `InetAddress.getByName(hostname)`.

### **4.5. Vulnerable Code Example: Server-Side Includes with User Input**

```java
String page = request.getParameter("page");
RequestDispatcher dispatcher = request.getRequestDispatcher("/pages/" + page);
dispatcher.include(request, response);
```

**Why It's Vulnerable**:

- `page` parameter is used to include server-side resources without validation.
- Attackers can access unauthorized files or execute scripts.

**Regex Match Explanation**:

- The pattern captures `request.getRequestDispatcher(...)` with dynamic paths.

---

<a name="interpreting-findings"></a>
## **5. Interpreting and Validating Findings**

- **Trace User Input Sources**: Identify where user input is used to construct URLs or network requests.
- **Assess Validation Logic**: Check if the application validates or sanitizes the input before using it.
- **Review Allowed Destinations**: Determine if the application restricts requests to specific domains or IP ranges.
- **Consider the Impact**: Evaluate what internal resources could be accessed if the vulnerability is exploited.
- **Test with Edge Cases**: Think about how an attacker might manipulate inputs to bypass validation (e.g., using IP addresses, DNS rebinding).
- **Beware of False Positives**: Some uses may be safe if proper validation is implemented elsewhere.

**Example**:

- If the application allows users to specify an image URL but validates that the URL points to an image on an allowed domain, the risk is mitigated.
- If no validation is performed, or validation can be bypassed, it's a high-risk vulnerability.

---

<a name="prevention"></a>
## **6. Best Practices for Prevention**

### **6.1. Do Not Use User Input Directly in Network Requests**

- **Avoid Direct Use**: Never use user-supplied URLs or hostnames directly in network requests.

**Example**:

```java
// Avoid using user input directly
String url = request.getParameter("url");
// Do not use 'url' directly in network requests
```

### **6.2. Implement Whitelisting of Allowed URLs and Domains**

- **Define Allowed Destinations**: Maintain a list of permissible domains or IP addresses.

**Example**:

```java
String url = request.getParameter("url");
List<String> allowedDomains = Arrays.asList("example.com", "api.example.com");

try {
    URL parsedUrl = new URL(url);
    String host = parsedUrl.getHost();

    if (allowedDomains.contains(host)) {
        // Proceed with the request
        InputStream is = parsedUrl.openStream();
        // Process the input stream
    } else {
        throw new SecurityException("Unauthorized domain");
    }
} catch (MalformedURLException e) {
    throw new IllegalArgumentException("Invalid URL");
}
```

### **6.3. Validate and Sanitize User Input**

- **URL Validation**: Ensure the input is a valid URL and conforms to expected patterns.

**Example**:

```java
String url = request.getParameter("url");

if (!isValidUrl(url)) {
    throw new IllegalArgumentException("Invalid URL");
}

// Validation method
private boolean isValidUrl(String url) {
    try {
        new URL(url);
        return true;
    } catch (MalformedURLException e) {
        return false;
    }
}
```

### **6.4. Restrict Protocols**

- **Allow Only HTTP and HTTPS**: Reject URLs using other protocols like `file://`, `ftp://`, etc.

**Example**:

```java
URL parsedUrl = new URL(url);
String protocol = parsedUrl.getProtocol();

if (!protocol.equals("http") && !protocol.equals("https")) {
    throw new SecurityException("Invalid protocol");
}
```

### **6.5. Resolve and Validate IP Addresses**

- **Prevent DNS Rebinding**: Resolve the hostname to an IP address and check if it's within allowed ranges.

**Example**:

```java
InetAddress address = InetAddress.getByName(parsedUrl.getHost());
String ip = address.getHostAddress();

// Check if IP is within allowed ranges
if (isInternalIp(ip)) {
    throw new SecurityException("Access to internal IP addresses is prohibited");
}

// Validation method
private boolean isInternalIp(String ip) {
    return ip.startsWith("10.") || ip.startsWith("192.168.") || ip.startsWith("172.16.");
}
```

### **6.6. Use Server-Side Proxying Carefully**

- **Avoid Exposing Internal Network**: Be cautious when proxying requests on behalf of the user.

### **6.7. Implement Timeouts and Limits**

- **Prevent Denial of Service**: Set connection timeouts and limit response sizes.

**Example**:

```java
URLConnection connection = parsedUrl.openConnection();
connection.setConnectTimeout(5000); // 5 seconds
connection.setReadTimeout(5000);    // 5 seconds
```