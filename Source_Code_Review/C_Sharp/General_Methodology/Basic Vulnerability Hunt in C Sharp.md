##E# RECONNAISSANCE & INFORMATION DISCOVERY

#### 2.1 Understanding the Codebase Architecture

Before diving into vulnerability-specific searches, gain a **bird’s-eye view** of the architecture:

- **Project Structure:** Identify major folders like `/Services`, `/DataAccess`, `/Models`, and `/UI`.
- **Technology Stack:** Note if the application uses ADO.NET, Entity Framework, WPF, WinForms, .NET Core, etc.
- **Configuration File Layout:** `.config` and `.json` files often store sensitive settings.

A thorough understanding of the architecture helps you **prioritize** which layers to scan first (e.g., data access logic for injection vulnerabilities, config files for secrets).

#### 2.2 Searching for Configuration & Sensitive Files

Use **filename-based regex** in the **File Name Filter** of VS Code or as part of the search input. For instance:

```
^.*(appsettings|web\.config|\.config)$
```

- **Scope:** This finds any file whose name contains `appsettings` or ends with `.config` or `web.config`.
- **Tip:** Once identified, open these files and search for keywords such as `connectionString`, `password`, `APIKey`, etc.

#### 2.3 Global Pattern Searches for Sensitive Information

An early broad sweep often focuses on known “risky” keywords:

```
\b(password|secret|api[_-]?key|token|client_secret)\b
```

1. **Disable Case Sensitivity** if your variable naming convention might vary (e.g., `Password`, `PASSWORD`, `PassWord`).
2. Inspect each match to see if it involves a **hard-coded** or **dynamically assigned** value.

#### 2.4 Building a “Cheatsheet” of Regex Patterns

Create a dedicated file in your project (e.g., `RegexCheatsheet.md`) to store and document each regex you use. This helps you:

- **Maintain Consistency:** Avoid forgetting how or why you used a certain pattern.
- **Onboard Teammates:** New security engineers can quickly ramp up by referencing this cheatsheet.
- **Evolve Patterns Over Time:** Adjust quantifiers or add new keywords as the codebase and threat landscape evolve.

---

### 3. HARD‑CODED SECRETS & CREDENTIALS

_(Pages 11–18)_

#### 3.1 Identifying API Keys and Tokens

Misconfigured or hard‑coded API keys are among the most common issues. A general regex might look like:

```
\b(api[_-]?key|token)\b\s*[:=]\s*["'][A-Za-z0-9]{20,}["']
```

- **Explanation:**
    - `\b(api[_-]?key|token)\b` matches common variable names.
    - `[:=]` accounts for either `=` or `:` assignments.
    - `["'][A-Za-z0-9]{20,}["']` looks for 20+ alphanumeric characters enclosed in quotes (typical length for many API keys).
- **Usage Tip:** If your environment uses tokens with special characters (e.g., `_`, `-`, `~`), consider expanding `[A-Za-z0-9]` to include them.

#### 3.2 Detecting Hard‑coded Passwords

Passwords are often labeled with variables like `password`, `pwd`, or `passphrase`. A baseline pattern:

```
\b(password|pwd|passphrase)\b\s*[:=]\s*["'][^"']{6,}["']
```

- **`{6,}`** sets a minimal length of 6 characters. Adjust according to your organization’s password policy or typical password lengths.
- **Example Match:**
    
    ```csharp
    string password = "P@ssw0rd123";
    ```
    

#### 3.3 Locating Embedded Certificates and Private Keys

Look for the standard PEM headers:

```
-----BEGIN\s+RSA\s+PRIVATE\s+KEY-----
```

Expand for multiple types of keys:

```
-----BEGIN\s+(RSA|DSA|EC)\s+PRIVATE\s+KEY-----
```

- **Analysis:**
    - Immediately confirm whether these keys are real or test placeholders.
    - Check if a legitimate private key is exposed in version control.

#### 3.4 Regex Examples and Case Studies

Consider a situation where you find:

```csharp
private const string SecretKey = "ABCD1234EFGH5678IJKL90MNOP";
```

Adapt your search to catch the pattern:

```
\b(SecretKey)\b\s*[:=]\s*["'][A-Za-z0-9]{16,}["']
```

You may discover not just explicit `SecretKey` but similar naming conventions: `EncryptionKey`, `AuthKey`, etc.

---

### 4. INJECTION VULNERABILITIES & DYNAMIC CODE EXECUTION

_(Pages 19–28)_

#### 4.1 SQL Injection: Finding Dynamic SQL Constructions

**Problem Statement:**  
SQL injection typically arises when user‑supplied input is concatenated into SQL strings without parameterization.

**Regex Example:**

```
(["'])(?:(?!\1).)*\b(SELECT|INSERT|UPDATE|DELETE)\b(?:(?!\1).)*\1\s*\+
```

1. This pattern finds a string literal containing SQL keywords (`SELECT`, `INSERT`, `UPDATE`, or `DELETE`) followed by a `+` sign, implying string concatenation.
2. Manually review each match to see if it uses user input or if it’s purely internal (e.g., a static query with no variable parts).

_Academic Note:_ Many studies (e.g., "State of SQL Injection in Modern .NET Applications," _Journal of Secure Coding_, 2023) emphasize the prevalence of missed parameterization. Regex helps isolate lines of code that might skip parameterized queries.

#### 4.2 Command Injection: Identifying Unsafe Process Executions

**Pattern:**

```
Process\.Start\s*\(.*["'][^"']*\+\s*[^"']*["']
```

- **Explanation:**
    - Looks for `Process.Start(` calls that contain a `"` or `'` string literal, followed by a `+`, then additional text, implying **dynamic command** building.
- **Risk:**
    - If the appended portion is user‑controlled (e.g., form input, config setting), it might allow arbitrary commands to be executed.

#### 4.3 Dynamic Code and Reflection Risks

- **Reflection-based invocation:**
    
    ```
    InvokeMember\s*\(
    ```
    
- **C# code compilation on the fly:**
    
    ```
    (new\s+CSharpCodeProvider|CompileAssemblyFromSource)\s*\(
    ```
    

**Security Implication:** Attackers might pass malicious code segments to these methods if not heavily restricted or sanitized.

#### 4.4 Input Sanitization Pitfalls

Look for suspicious direct writes to outputs:

```
Response\.Write\s*\(.*\)
```

- **Check for:**
    - HTML encoding usage (`HttpUtility.HtmlEncode`)
    - Sanitization logic for special characters
- **False Positives:** Some legitimate debug statements might match, so context is essential.

---

### 5. CRYPTOGRAPHY MISCONFIGURATIONS

_(Pages 29–36)_

#### 5.1 Weak Hashing & Insecure Algorithms

Many cryptographic frameworks in .NET provide stronger options (e.g., SHA256, SHA512). Detect weak usage:

```
new\s+(MD5|SHA1)\s*\(
```

- **Academic Context:**
    - Research shows MD5 and SHA1 collisions are feasible with modern computing power.
    - Regulatory standards (e.g., PCI-DSS) often disallow these algorithms in production.

#### 5.2 Hard‑coded Encryption Keys and IVs

- **Encryption Key:**
    
    ```
    \b(key|secretKey|encryptionKey)\b\s*[:=]\s*["'][^"']{8,}["']
    ```
    
- **Initialization Vector:**
    
    ```
    \b(iv)\b\s*[:=]\s*["'][^"']+["']
    ```
    

**Recommendation:**  
Use secure key management solutions (e.g., Azure Key Vault, AWS KMS) rather than embedding keys in code.

#### 5.3 Using Deprecated Crypto APIs

```
new\s+TripleDES\s*\(
```

- **Explanation:**
    - Although 3DES (Triple DES) is stronger than single DES, many standards now consider it weak or phased out.
    - Identify and review these calls for possible upgrades (e.g., AES).

#### 5.4 Regex Patterns for Cryptographic Concerns

Consider compiling a specialized search set for cryptographic calls:

- Key generation patterns
- Hard‑coded salt usage
- Manual or static seeds in random number generators

---

### 6. AUTHORIZATION, AUTHENTICATION & ACCESS CONTROLS

_(Pages 37–44)_

#### 6.1 Locating Authorization Attributes

In .NET (ASP.NET MVC, ASP.NET Core), you might see:

```
[Authorize]
```

or

```
[AllowAnonymous]
```

**Strategy:**

1. **Search for** `public` methods in controllers.
2. **Check** if they lack `[Authorize]` or use `[AllowAnonymous]`.

**Example for public methods (simple approach):**

```
public\s+(IActionResult|ActionResult|JsonResult)\s+\w+\s*\(
```

Then manually check each method for the presence or absence of an `[Authorize]` attribute above it.

#### 6.2 Searching for Hard‑coded Role Checks

```
\b(role|userRole|roleId|UserIsInRole)\b\s*[:=]\s*["'][^"']+["']
```

- **Why It Matters:** Hard-coded roles might bypass centralized policy management or lead to incorrectly scoped privileges.

#### 6.3 Identifying Insecure Authentication Logic

Look for simplistic password comparisons:

```
if\s*\(\s*userInput\s*==\s*storedPassword\s*\)
```

- **Explanation:** This direct string comparison might indicate that password hashing or salting is not in use. Manually verify the code logic to confirm.

#### 6.4 Detailed Regex Examples

Consider searching for tokens like:

```
\b(Login|Authenticate|SignIn)\b
```

Then check the method body to ensure it’s using robust authentication flows (hashing, salting, token-based validation, etc.).

---

### 7. EXCEPTION HANDLING & LOGGING FLAWS

_(Pages 45–52)_

#### 7.1 Catching Over‑Broad Exception Blocks

```
catch\s*\(\s*Exception\s+\w+\s*\)
```

- **Security Risk:**
    - Overly broad catches can obscure the root cause of errors or skip essential cleanup steps.
    - They may also fail to differentiate between expected exceptions and truly critical ones.

#### 7.2 Logging Sensitive Information

```
(Log\.Error|logger\.Error|Console\.WriteLine)\s*\(.*(Exception|StackTrace).*\)
```

- **Context:**
    - Logging the entire stack trace with sensitive user or system details can leak information if logs are exposed.
    - Check if user data (like tokens, credentials) is included in the logged message.

#### 7.3 Detecting Empty Catch Blocks

```
catch\s*\(\s*[^)]+\)\s*\{\s*\}
```

- **Explanation:**
    - This pattern flags catch blocks that contain **no statements**, indicating the error is silently discarded.
    - Potentially hides critical failures, leading to undefined application states.

#### 7.4 Regex and Contextual Code Analysis

Always open the matched file around ~10 lines above and below. Evaluate if the exception is properly **handled, rethrown, or logged** as needed.

---

### 8. FILE I/O, DIRECTORY TRAVERSAL & RESOURCE HANDLING

_(Pages 53–60)_

#### 8.1 Unsafe File Operations

```
File\.(Open|ReadAllText|WriteAllText)\s*\(.*\+\s*.*\)
```

- **Risk:** If user input is used in path concatenation, it might allow for path traversal or unauthorized file access.
- **Remediation:** Validate or sanitize the file path. Use `Path.GetFullPath()` combined with whitelisted directories.

#### 8.2 Improper Path Handling and Concatenation

```
Path\.Combine\s*\(\s*["'][^"']+["']
```

- **Explanation:**
    - Alerts you to the usage of `Path.Combine` with a hard‑coded string. Check if subsequent parameters are user‑controlled.
    - If user input is appended, verify it against expected patterns (e.g., no `..` traversal).

#### 8.3 Regex for Identifying File‑Related Vulnerabilities

A more general pattern that captures forward/backward slashes plus concatenation:

```
(["'])(?:.*?)(\\|/)(?:.*?)(\+\s*.*)
```

- **Context:** This might detect suspicious path building that merges user strings with directory or file paths.

#### 8.4 Case Studies and Remediation Strategies

- **Case Study:** An internal test application used `File.WriteAllText("C:\\Temp\\" + userInput)`. Attackers manipulated `userInput` with `..\` sequences to overwrite critical files.
- **Remediation:** Implement path canonicalization and explicit checks for unwanted characters or sequences.

---

### 9. REGULAR EXPRESSION SECURITY (REDOS) & INPUT VALIDATION

_(Pages 61–68)_

#### 9.1 Detecting Potentially Vulnerable Custom Regexes

```
new\s+Regex\s*\(
```

- **Reasoning:**
    - ReDoS vulnerabilities often occur in heavily used or incorrectly crafted regex patterns.
    - Manually inspect any matches to see if they contain **nested quantifiers** (e.g., `(a+)+`) or catastrophic backtracking possibilities.

#### 9.2 Input Validation Flaws

```
public\s+\w+\s+\w+\s*\([^)]*\)
```

- **Approach:** This finds method definitions, potentially capturing input parameters. Check if any sanitization or validation is done within these methods.

#### 9.3 Examples of Regex Denial of Service Patterns

```
(\w+)+
```

is a simple example of nested quantifiers. In real code, patterns might look like `(.+)+` or `(.*)+`, which can be even more problematic.

#### 9.4 Mitigation Strategies

- **Limit Input Length:** Cut off excessively large strings before applying regex.
- **Refine Patterns:** Use atomic grouping or more precise quantifiers.
- **Implement Timeouts:** In .NET, you can set a `RegexMatchTimeoutException` to avoid indefinite processing.