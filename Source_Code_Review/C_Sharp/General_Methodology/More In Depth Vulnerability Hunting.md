## 1. Hardcoded Secrets / Credentials

Developers may inadvertently embed passwords, API keys, tokens, connection strings, or other sensitive values directly in source files and configuration files. The following regexes help identify many different coding scenarios where such secrets might appear.

**1.1 XML tags with sensitive keywords**

```regex
<[^>]*(password|secret|token|apikey|credential|connectionstring)[^>]*>[^<]*</[^>]*>
```

_Explanation:_ Searches for XML tags (e.g., in `.csproj` or config files) whose tag names or attributes include keywords like “password” or “secret” and then extracts the content between the tags.  
_Example:_

```xml
<PropertyGroup>
  <ConnectionString>Server=myServer;Database=myDB;User Id=myUser;Password=MySuperSecret!</ConnectionString>
</PropertyGroup>
```

_Security Impact:_ Exposed credentials could allow unauthorized access to databases or services.

---

**1.2 XML attribute assignments**

```regex
(password|secret|token|apikey|credential|connectionstring)\s*=\s*"[^"]+"
```

_Explanation:_ Matches attribute assignments in XML files where the attribute name is one of the sensitive keywords.  
_Example:_

```xml
<PropertyGroup>
  <Password value="MySecretPassword123" />
  <ApiKey value="abc123XYZ987" />
</PropertyGroup>
```

_Security Impact:_ Hardcoded values can be harvested from source control and misused.

---

**1.3 C# variable assignments with secret names**

```regex
var\s+(password|secret|token|apikey|credential)[A-Za-z0-9_]*\s*=\s*".+";
```

_Explanation:_ Looks for C# variable declarations whose names contain sensitive keywords and that are directly assigned a string literal.  
_Example:_

```csharp
var apiToken = "98765secretTokenValue";
```

_Security Impact:_ Reveals secrets in source code, enabling attackers to bypass authentication.

---

**1.4 Connection strings embedded in code**

```regex
"(Server|Data Source)=.+;(User Id|UID)=.+;(Password|PWD)=.+;"
```

_Explanation:_ Matches literal strings resembling a database connection string.  
_Example:_

```csharp
string connStr = "Server=192.168.1.10;User Id=admin;Password=SuperSecretPass;Database=ProdDB;";
```

_Security Impact:_ Hardcoded connection strings can be exploited to directly access databases.

---

**1.5 Variable names including pass or pwd**

```regex
[A-Za-z0-9_]*(pass|pwd)[A-Za-z0-9_]*\s*[:=]\s*".+"
```

_Explanation:_ Identifies assignments to variables whose names include “pass” or “pwd”.  
_Example:_

```csharp
string userPwd = "UserPassword123!";
```

_Security Impact:_ Directly discloses credentials that could be abused.

---

**1.6 JSON key-value pairs for API keys**

```regex
"(api|auth)Key"\s*:\s*".+"
```

_Explanation:_ Searches JSON files for key names like “apiKey” or “authKey” that are assigned string literals.  
_Example:_

```json
{
  "apiKey": "ABCdef1234567890"
}
```

_Security Impact:_ Exposes keys that can be used to access external services.

---

**1.7 JSON token assignments**

```regex
"(token|secret)"\s*:\s*".+"
```

_Explanation:_ Matches JSON entries that contain tokens or secrets.  
_Example:_

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

_Security Impact:_ Stolen tokens can lead to account compromise or privilege escalation.

---

**1.8 ASP.NET web.config credentials**

```regex
<add\s+key="(password|secret)"\s+value="[^"]+"
```

_Explanation:_ Targets ASP.NET configuration settings in web.config files where keys like “password” or “secret” are defined.  
_Example:_

```xml
<appSettings>
  <add key="password" value="ConfigSecretPassword!" />
</appSettings>
```

_Security Impact:_ Reveals sensitive configuration details that can be exploited by attackers.

---

**1.9 Hardcoded credentials in logging statements**

```regex
console\.log\(\s*".*(password|secret).*"\s*\);
```

_Explanation:_ Searches for logging calls that include secret-related keywords within string literals.  
_Example:_

```javascript
console.log("DEBUG: The password used is 'MyDebugPass123' for testing.");
```

_Security Impact:_ Logging sensitive information increases the attack surface if logs are exposed.

---

**1.10 Commented-out credentials or secrets**

```regex
\/\/.*(password|secret|token|apikey|credential)
```

_Explanation:_ Catches commented-out lines that reference sensitive information; even if not active, they can leak secrets.  
_Example:_

```csharp
// TODO: Remove hardcoded password = "TempPass123!" before production.
```

_Security Impact:_ Comments with credentials can provide attackers with clues to sensitive data.

---

## 2. SQL Injection / Dynamic SQL Vulnerabilities

Building SQL statements through string concatenation or improper parameterization can enable SQL injection attacks. The following regexes aim to detect dynamic SQL patterns that might be vulnerable.

**2.1 Concatenated SQL string literals**

```regex
"[^"]*(SELECT|INSERT|UPDATE|DELETE)[^"]*"\s*\+\s*
```

_Explanation:_ Looks for SQL keywords inside a string literal that is concatenated with another value.  
_Example:_

```csharp
string query = "SELECT * FROM Users WHERE UserId = " + userId;
```

_Security Impact:_ Dynamically built SQL queries can be manipulated by attackers to execute arbitrary SQL.

---

**2.2 Inline SQL in SqlCommand instantiation**

```regex
new\s+SqlCommand\s*\(\s*"[^"]*(SELECT|INSERT|UPDATE|DELETE)[^"]*"
```

_Explanation:_ Detects instances where an SQL command is directly constructed with inline SQL, increasing the risk of injection.  
_Example:_

```csharp
var cmd = new SqlCommand("UPDATE Users SET IsActive = 1 WHERE UserId = " + userId, connection);
```

_Security Impact:_ Direct SQL concatenation without parameters exposes the application to SQL injection.

---

**2.3 SQL WHERE clause concatenation**

```regex
".*WHERE\s+.*\s*=\s*"\s*\+\s*
```

_Explanation:_ Focuses on the WHERE clause, identifying SQL strings that are concatenated with variables.  
_Example:_

```csharp
string sql = "SELECT * FROM Orders WHERE OrderId = " + orderId;
```

_Security Impact:_ Unsanitized input in the WHERE clause may allow attackers to bypass authentication or extract data.

---

**2.4 FROM clause dynamic table names**

```regex
"[^"]*FROM\s+[A-Za-z0-9_]+\s+WHERE\s+[^"]*"\s*\+\s*
```

_Explanation:_ Identifies queries where even the table name or conditions are concatenated.  
_Example:_

```csharp
string query = "SELECT * FROM " + tableName + " WHERE IsActive = 1";
```

_Security Impact:_ Dynamic table names can lead to unauthorized access if not properly validated.

---

**2.5 Verbatim string dynamic SQL**

```regex
@".*SELECT\s+.*"\s*\+\s*
```

_Explanation:_ Captures the use of C# verbatim strings (`@""`) for constructing SQL that is then concatenated.  
_Example:_

```csharp
string sql = @"SELECT * FROM Products WHERE Category = '" + category + "'";
```

_Security Impact:_ Concatenated verbatim strings can be abused in injection attacks.

---

**2.6 SQL string assignment with concatenation**

```regex
\bstring\s+\w+\s*=\s*"SELECT\s+.*"\s*\+\s*
```

_Explanation:_ Detects when a string variable is assigned a SQL statement that is built by concatenation.  
_Example:_

```csharp
string query = "SELECT * FROM Employees WHERE Dept = '" + deptName + "'";
```

_Security Impact:_ Exposes the code to injection if `deptName` is not sanitized.

---

**2.7 SqlCommand ExecuteNonQuery concatenation**

```regex
\bExecuteNonQuery\s*\(\s*".*"\s*\+\s*\w+
```

_Explanation:_ Flags calls to `ExecuteNonQuery` where the SQL command is assembled via concatenation.  
_Example:_

```csharp
cmd.ExecuteNonQuery("DELETE FROM Sessions WHERE SessionId = " + sessionId);
```

_Security Impact:_ Dynamic SQL execution increases the likelihood of injection flaws.

---

**2.8 SqlCommand ExecuteReader concatenation**

```regex
\bExecuteReader\s*\(\s*".*"\s*\+\s*\w+
```

_Explanation:_ Similar to ExecuteNonQuery but for reader methods; these patterns can also be exploited.  
_Example:_

```csharp
var reader = cmd.ExecuteReader("SELECT * FROM Logs WHERE LogId = " + logId);
```

_Security Impact:_ Vulnerable SQL can expose sensitive data if exploited.

---

**2.9 General SQL concatenation with multiple variables**

```regex
"(SELECT|UPDATE|INSERT|DELETE)\s+.*"\s*\+\s*[^;]+
```

_Explanation:_ Captures SQL statements that include one or more concatenated variables, increasing risk.  
_Example:_

```csharp
string sql = "INSERT INTO AuditLog (UserId, Action) VALUES (" + userId + ", '" + action + "')";
```

_Security Impact:_ Multiple concatenation points can provide numerous injection vectors.

---

**2.10 Dynamic SQL in stored procedure calls**

```regex
"EXEC\s+[A-Za-z0-9_]+\s+[^"]+"\s*\+\s*
```

_Explanation:_ Identifies dynamic concatenation in stored procedure calls that are constructed from strings.  
_Example:_

```csharp
string procCall = "EXEC UpdateUserStatus " + userStatus;
```

_Security Impact:_ If inputs are not validated, attackers may manipulate stored procedure parameters.

---

## 3. OS Command Injection / Shell Injection

Executing operating system commands by concatenating strings with user input may allow attackers to run arbitrary commands. The regexes below help detect risky command construction patterns.

**3.1 Process.Start with concatenation**

```regex
Process\.Start\s*\(\s*".*?"\s*\+\s*
```

_Explanation:_ Matches calls to `Process.Start` where the command is built by concatenating a string literal with additional input.  
_Example:_

```csharp
Process.Start("cmd.exe", "/C " + userProvidedCmd);
```

_Security Impact:_ Allows attackers to execute arbitrary OS commands if `userProvidedCmd` is not sanitized.

---

**3.2 Fully qualified Process.Start usage**

```regex
System\.Diagnostics\.Process\.Start\s*\(\s*".*?"\s*\+\s*
```

_Explanation:_ Detects similar patterns when using the full namespace.  
_Example:_

```csharp
System.Diagnostics.Process.Start("powershell.exe", "-Command " + userInput);
```

_Security Impact:_ Untrusted input may lead to command injection.

---

**3.3 Cmd.exe concatenation with parameters**

```regex
Process\.Start\s*\(\s*".*cmd\.exe.*",\s*".*"\s*\+\s*
```

_Explanation:_ Specifically flags scenarios where `cmd.exe` is invoked with concatenated parameters.  
_Example:_

```csharp
Process.Start("cmd.exe", "/C " + maliciousParam);
```

_Security Impact:_ Exposes a pathway for attackers to execute system commands.

---

**3.4 Verbatim string usage with Process.Start**

```regex
Process\.Start\s*\(\s*@"cmd\.exe",\s*".*"\s*\+\s*
```

_Explanation:_ Detects the use of verbatim strings in building OS commands.  
_Example:_

```csharp
Process.Start(@"cmd.exe", @"/C " + userArg);
```

_Security Impact:_ Even verbatim strings can be dangerous if user input is appended unsafely.

---

**3.5 Dynamic command execution via reflection**

```regex
Runtime\.InvokeMember\s*\(\s*".*"\s*\+\s*
```

_Explanation:_ Flags usage of reflection or dynamic invocation where a command string is constructed via concatenation.  
_Example:_

```csharp
runtime.InvokeMember("Execute" + userCommand, BindingFlags.InvokeMethod, null, null, null);
```

_Security Impact:_ Opens up potential avenues for code execution via manipulated input.

---

**3.6 Shell execution in scripting APIs**

```regex
shell\.Exec\s*\(\s*".*"\s*\+\s*
```

_Explanation:_ Matches calls to a hypothetical shell execution API where input is concatenated into the command.  
_Example:_

```javascript
shell.Exec("sh -c " + untrustedCommand);
```

_Security Impact:_ Direct shell execution can be exploited to run arbitrary commands.

---

**3.7 ProcessStartInfo with dynamic arguments**

```regex
new\s+ProcessStartInfo\s*\(\s*".*"\s*\)\.Arguments\s*=\s*".*"\s*\+\s*
```

_Explanation:_ Searches for instances where process start info objects have their arguments built from concatenated strings.  
_Example:_

```csharp
var psi = new ProcessStartInfo("app.exe");
psi.Arguments = "--option " + userInput;
```

_Security Impact:_ Manipulated arguments can lead to unexpected behavior or command injection.

---

**3.8 ProcessStartInfo property assignment with concatenation**

```regex
System\.Process\.StartInfo\s*\.\s*Arguments\s*=\s*".*"\s*\+\s*
```

_Explanation:_ Catches cases where process start information is modified with unsafe string concatenation.  
_Example:_

```csharp
process.StartInfo.Arguments = "-run " + commandParam;
```

_Security Impact:_ May allow injection of malicious parameters into a subprocess.

---

**3.9 Cmd command with /C option concatenation**

```regex
Process\.Start\s*\(\s*"(?:/c|/C)\s*".*"\s*\+\s*
```

_Explanation:_ Targets instances where command line arguments using the `/C` flag are concatenated with external input.  
_Example:_

```csharp
Process.Start("cmd.exe", "/C " + extraCmd);
```

_Security Impact:_ Unsanitized command strings can lead to full command injection.

---

**3.10 Absolute path command concatenation**

```regex
Process\.Start\s*\(\s*"[A-Za-z]:\\\\[^"]+"\s*,\s*".*"\s*\+\s*
```

_Explanation:_ Looks for OS command calls using absolute paths where additional arguments are appended unsafely.  
_Example:_

```csharp
Process.Start("C:\\Windows\\System32\\net.exe", "use " + networkPath);
```

_Security Impact:_ May allow attackers to manipulate critical system commands.

---

## 4. Insecure Cryptographic Practices

Using weak cryptographic algorithms or hardcoding cryptographic keys can compromise data integrity and confidentiality. These regexes are designed to highlight potential issues in cryptographic code.

**4.1 Weak hash algorithms usage**

```regex
\b(MD5|SHA1)\b
```

_Explanation:_ Searches for the insecure hash algorithms MD5 or SHA1 in code.  
_Example:_

```csharp
var hash = MD5.Create().ComputeHash(data);
```

_Security Impact:_ Weak algorithms can be broken, making sensitive data vulnerable.

---

**4.2 Legacy crypto service provider usage**

```regex
CryptoServiceProvider\s*\(\s*\)
```

_Explanation:_ Identifies use of older crypto providers that may not meet modern security standards.  
_Example:_

```csharp
var provider = new CryptoServiceProvider();
```

_Security Impact:_ These providers may use outdated practices susceptible to attacks.

---

**4.3 Explicit MD5CryptoServiceProvider instantiation**

```regex
new\s+MD5CryptoServiceProvider\s*\(
```

_Explanation:_ Matches explicit instantiation of MD5 crypto providers.  
_Example:_

```csharp
using (var md5 = new MD5CryptoServiceProvider()) { ... }
```

_Security Impact:_ MD5 is considered broken and should be replaced by stronger algorithms.

---

**4.4 Explicit SHA1CryptoServiceProvider instantiation**

```regex
new\s+SHA1CryptoServiceProvider\s*\(
```

_Explanation:_ Flags use of SHA1 crypto provider instantiations.  
_Example:_

```csharp
using (var sha1 = new SHA1CryptoServiceProvider()) { ... }
```

_Security Impact:_ SHA1 is vulnerable to collision attacks.

---

**4.5 Deprecated TripleDES usage**

```regex
new\s+TripleDESCryptoServiceProvider\s*\(
```

_Explanation:_ Detects usage of TripleDES which is generally deprecated in favor of AES.  
_Example:_

```csharp
var tripleDes = new TripleDESCryptoServiceProvider();
```

_Security Impact:_ TripleDES may not offer sufficient security margins against modern attacks.

---

**4.6 Hardcoded base64-like keys**

```regex
\w+\s*=\s*"([A-Za-z0-9+/]{16,})"
```

_Explanation:_ Matches variable assignments with long base64 strings that might represent cryptographic keys.  
_Example:_

```csharp
string encryptionKey = "QWxhZGRpbjpPcGVuU2VzYW1l";
```

_Security Impact:_ Hardcoded keys can be extracted and used to decrypt sensitive data.

---

**4.7 Explicit encryption key assignment**

```regex
encryptionKey\s*=\s*"[A-Za-z0-9]{16,}"
```

_Explanation:_ Captures assignments where a variable named “encryptionKey” is directly set to a literal.  
_Example:_

```csharp
string encryptionKey = "Abcdefghijklmnop";
```

_Security Impact:_ Reveals the encryption key, undermining the confidentiality of encrypted data.

---

**4.8 Key assignment using common labels**

```regex
Key\s*[:=]\s*"[A-Za-z0-9+/=]{16,}"
```

_Explanation:_ Detects assignments to variables labeled “Key” which might be used in cryptographic operations.  
_Example:_

```csharp
var Key = "MDEyMzQ1Njc4OWFiY2RlZg==";
```

_Security Impact:_ Hardcoded keys may allow attackers to decrypt or tamper with sensitive information.

---

**4.9 Initialization vector (IV) assignments**

```regex
IV\s*[:=]\s*"[A-Za-z0-9+/=]{16,}"
```

_Explanation:_ Matches instances where an IV is hardcoded into the source code.  
_Example:_

```csharp
string IV = "1234567890abcdef";
```

_Security Impact:_ Fixed IVs reduce the randomness required for secure encryption schemes.

---

**4.10 Dynamic AES creation**

```regex
Aes\.Create\s*\(\s*\)
```

_Explanation:_ Identifies use of AES creation methods; while AES is secure, ensure keys/IVs aren’t hardcoded.  
_Example:_

```csharp
using (Aes aes = Aes.Create()) { /* Configure key/IV dynamically */ }
```

_Security Impact:_ Misuse (such as hardcoding parameters) can compromise even strong algorithms like AES.

---

## 5. Hardcoded Sensitive Endpoints and URLs

Embedding URLs, IP addresses, or endpoint details in code may leak internal network information. Use the following regexes to identify such occurrences.

**5.1 HTTP/HTTPS URLs in string literals**

```regex
https?://[^"]+
```

_Explanation:_ Matches any string literal starting with “http://” or “https://”.  
_Example:_

```csharp
string apiUrl = "https://api.example.com/getData";
```

_Security Impact:_ Reveals network endpoints that can be exploited for targeted attacks.

---

**5.2 FTP URLs detection**

```regex
ftp://[^"]+
```

_Explanation:_ Catches hardcoded FTP links which might expose legacy file transfer endpoints.  
_Example:_

```csharp
string ftpServer = "ftp://192.168.1.20/files";
```

_Security Impact:_ May expose internal FTP servers that lack proper security.

---

**5.3 XML endpoint definitions**

```regex
<endpoint>\s*https?://[^<]+</endpoint>
```

_Explanation:_ Identifies endpoints defined within XML tags.  
_Example:_

```xml
<endpoint>https://internal.example.com/api</endpoint>
```

_Security Impact:_ Disclosing internal endpoints can aid reconnaissance by attackers.

---

**5.4 Base URL assignments in code**

```regex
baseUrl\s*=\s*"https?://[^"]+"
```

_Explanation:_ Detects assignments to a “baseUrl” variable that are hardcoded.  
_Example:_

```csharp
var baseUrl = "https://service.company.com/v1";
```

_Security Impact:_ Hardcoding URLs reveals infrastructure details.

---

**5.5 New Uri object creation with URLs**

```regex
new\s+Uri\s*\(\s*"https?://[^"]+"\s*\)
```

_Explanation:_ Flags instances where a new URI object is created from a hardcoded URL.  
_Example:_

```csharp
Uri endpoint = new Uri("https://data.example.org/resource");
```

_Security Impact:_ Exposes sensitive endpoints in the codebase.

---

**5.6 Localhost and loopback address detection**

```regex
"(localhost|127\.0\.0\.1):\d{2,5}"
```

_Explanation:_ Matches hardcoded references to localhost or loopback addresses with port numbers.  
_Example:_

```csharp
string localUrl = "http://127.0.0.1:8080/api";
```

_Security Impact:_ Reveals internal testing endpoints that might be misconfigured.

---

**5.7 Internal private IP address detection (10.x.x.x)**

```regex
"(10\.\d{1,3}\.\d{1,3}\.\d{1,3})"
```

_Explanation:_ Searches for hardcoded IP addresses within the 10.0.0.0/8 private range.  
_Example:_

```csharp
string internalIP = "10.0.0.5";
```

_Security Impact:_ Discloses internal network structures.

---

**5.8 Internal private IP address detection (192.168.x.x)**

```regex
"(192\.168\.\d{1,3}\.\d{1,3})"
```

_Explanation:_ Matches hardcoded IP addresses from the common 192.168.x.x range.  
_Example:_

```csharp
string serverIP = "192.168.1.100";
```

_Security Impact:_ Reveals internal network details.

---

**5.9 Verbatim URL strings in code**

```regex
@"https?://[^"]+"
```

_Explanation:_ Captures URLs defined using verbatim string literals.  
_Example:_

```csharp
string apiEndpoint = @"https://api.company.com/endpoint";
```

_Security Impact:_ Hardcoded endpoints can be used to map the network structure.

---

**5.10 Generic endpoint assignment detection**

```regex
endpoint\s*=\s*"https?://[^"]+"
```

_Explanation:_ Matches assignments to variables named “endpoint” containing URLs.  
_Example:_

```csharp
var endpoint = "https://internal.company.net/service";
```

_Security Impact:_ Exposes internal service addresses to potential attackers.

---

## 6. Insecure Error Handling and Logging

Detailed error logging can inadvertently expose internal state, stack traces, and sensitive data. The following regexes help pinpoint risky logging practices.

**6.1 Catch blocks logging exception details via Console**

```regex
catch\s*\(\s*Exception\s*\w*\)\s*\{[^}]*Console\.Write(Line)?\(
```

_Explanation:_ Detects catch blocks that output exception details using `Console.Write` or `Console.WriteLine`.  
_Example:_

```csharp
catch(Exception ex) {
    Console.WriteLine(ex.ToString());
}
```

_Security Impact:_ Revealing stack traces or exception details can help an attacker understand the code structure.

---

**6.2 Logger.LogError with exception details**

```regex
logger\.LogError\s*\(\s*exception\.ToString\(\)\s*\)
```

_Explanation:_ Matches logging calls where the full exception details are logged.  
_Example:_

```csharp
logger.LogError(exception.ToString());
```

_Security Impact:_ Detailed logs may reveal sensitive internal data.

---

**6.3 Direct stack trace logging via Console**

```regex
Console\.Write(Line)?\s*\(\s*ex\.StackTrace\s*\)
```

_Explanation:_ Detects instances where stack traces are directly printed to the console.  
_Example:_

```csharp
Console.WriteLine(ex.StackTrace);
```

_Security Impact:_ Stack traces can reveal file paths and internal logic to attackers.

---

**6.4 Debug.Write with exception messages**

```regex
Debug\.Write(Line)?\s*\(\s*ex\.Message\s*\)
```

_Explanation:_ Flags logging of exception messages via debugging statements.  
_Example:_

```csharp
Debug.WriteLine(ex.Message);
```

_Security Impact:_ Even seemingly harmless messages might reveal system details.

---

**6.5 LogManager error logging of exceptions**

```regex
LogManager\.GetLogger\([^)]+\)\.Error\s*\(\s*ex\s*\)
```

_Explanation:_ Captures usage of LogManager where exceptions are logged wholesale.  
_Example:_

```csharp
LogManager.GetLogger("AppLogger").Error(ex);
```

_Security Impact:_ May expose sensitive error details if logs are compromised.

---

**6.6 System.Diagnostics.Trace logging**

```regex
System\.Diagnostics\.Trace\.WriteLine\s*\(\s*ex\.ToString\(\)\s*\)
```

_Explanation:_ Detects trace logging that outputs full exception details.  
_Example:_

```csharp
System.Diagnostics.Trace.WriteLine(ex.ToString());
```

_Security Impact:_ Provides attackers with insight into application internals.

---

**6.7 Generic Log.Error usage**

```regex
Log\.\s*Error\s*\(\s*exception\s*\)
```

_Explanation:_ Matches generic logging of an exception object.  
_Example:_

```csharp
Log.Error(exception);
```

_Security Impact:_ Without proper sanitization, error objects can leak sensitive information.

---

**6.8 Fatal logging of exception messages**

```regex
Log\.\s*Fatal\s*\(\s*ex\.Message\s*\)
```

_Explanation:_ Flags fatal logs that output exception messages directly.  
_Example:_

```csharp
Log.Fatal(ex.Message);
```

_Security Impact:_ Fatal logs might be monitored externally, inadvertently exposing internal errors.

---

**6.9 Error logging combining strings and exceptions**

```regex
Log\.Error\s*\(\s*".*"+\s*ex\s*\)
```

_Explanation:_ Detects logging statements that combine custom strings with exception objects.  
_Example:_

```csharp
Log.Error("Error occurred: " + ex);
```

_Security Impact:_ Composite logs can expose both developer messages and sensitive error data.

---

**6.10 Logger usage with concatenated exception details**

```regex
logger\.Error\s*\(\s*".*"+\s*exception\.ToString\(\)\s*\)
```

_Explanation:_ Matches logger calls that concatenate messages with full exception details.  
_Example:_

```csharp
logger.Error("Critical failure: " + exception.ToString());
```

_Security Impact:_ May inadvertently provide attackers with clues to the application's internal structure.

---

## 7. Insecure File I/O Operations and Path Traversal

Dynamic file and path operations that incorporate user input can lead to unauthorized file access or path traversal vulnerabilities. The regexes below focus on risky file I/O patterns.

**7.1 ReadAllText with dynamic input**

```regex
File\.ReadAllText\s*\(\s*[^)]+\)
```

_Explanation:_ Matches calls to read file contents where the file path is dynamically provided.  
_Example:_

```csharp
var data = File.ReadAllText(userInputPath);
```

_Security Impact:_ May allow attackers to read arbitrary files if `userInputPath` isn’t properly sanitized.

---

**7.2 WriteAllText with dynamic input**

```regex
File\.WriteAllText\s*\(\s*[^)]+\)
```

_Explanation:_ Detects file writing operations where the target path is determined at runtime.  
_Example:_

```csharp
File.WriteAllText(userProvidedPath, "Sensitive data");
```

_Security Impact:_ Can be exploited for unauthorized file writes or overwrites.

---

**7.3 ReadAllBytes with dynamic input**

```regex
File\.ReadAllBytes\s*\(\s*[^)]+\)
```

_Explanation:_ Flags operations that read binary file data from dynamic paths.  
_Example:_

```csharp
byte[] fileData = File.ReadAllBytes(requestedFile);
```

_Security Impact:_ Could expose sensitive binary files if input is not validated.

---

**7.4 Path.Combine with dynamic segments**

```regex
Path\.Combine\s*\(\s*[^)]+\)
```

_Explanation:_ Catches use of `Path.Combine` where one or more segments may come from untrusted sources.  
_Example:_

```csharp
string fullPath = Path.Combine(baseDirectory, userInputFile);
```

_Security Impact:_ If not properly sanitized, attackers may navigate outside the intended directory.

---

**7.5 StreamReader initialization with dynamic path**

```regex
new\s+StreamReader\s*\(\s*[^)]+\)
```

_Explanation:_ Matches creation of new StreamReader objects with file paths that might be tainted.  
_Example:_

```csharp
var reader = new StreamReader(requestedFilePath);
```

_Security Impact:_ Unauthorized reading of files can occur.

---

**7.6 StreamWriter initialization with dynamic path**

```regex
new\s+StreamWriter\s*\(\s*[^)]+\)
```

_Explanation:_ Detects new StreamWriter usage for writing to files with dynamic paths.  
_Example:_

```csharp
var writer = new StreamWriter(userSuppliedOutputPath);
```

_Security Impact:_ Risk of file overwrite or data corruption if the path is not validated.

---

**7.7 FileStream creation with dynamic file paths**

```regex
FileStream\s*\(\s*[^)]+\)
```

_Explanation:_ Flags FileStream objects created with potentially unsafe paths.  
_Example:_

```csharp
var fs = new FileStream(inputFile, FileMode.Open);
```

_Security Impact:_ Unauthorized file access may be enabled.

---

**7.8 File.OpenRead with dynamic file names**

```regex
File\.OpenRead\s*\(\s*[^)]+\)
```

_Explanation:_ Matches file read operations where file names come from external inputs.  
_Example:_

```csharp
var fileStream = File.OpenRead(userFilePath);
```

_Security Impact:_ May allow reading of arbitrary files if input validation is weak.

---

**7.9 Directory.GetFiles with dynamic directory names**

```regex
Directory\.GetFiles\s*\(\s*[^)]+\)
```

_Explanation:_ Detects directory listing operations on dynamically supplied paths.  
_Example:_

```csharp
string[] files = Directory.GetFiles(userDirectory);
```

_Security Impact:_ Can reveal sensitive directory structures if exploited.

---

**7.10 FileInfo instantiation with dynamic input**

```regex
System\.IO\.FileInfo\s*\(\s*[^)]+\)
```

_Explanation:_ Catches the creation of FileInfo objects where the file path is not hardcoded.  
_Example:_

```csharp
var fileInfo = new System.IO.FileInfo(userSpecifiedFile);
```

_Security Impact:_ May provide attackers with file metadata or enable file enumeration.

---

## 8. Unsafe Reflection and Dynamic Code Execution

Improper use of reflection and dynamic type loading may allow execution of untrusted code. Use these regexes to detect risky reflection patterns.

**8.1 Dynamic assembly loading via Assembly.Load**

```regex
Assembly\.Load(From)?\s*\(\s*[^)]+\)
```

_Explanation:_ Matches calls that dynamically load assemblies using Assembly.Load or Assembly.LoadFrom.  
_Example:_

```csharp
var asm = Assembly.Load("UntrustedAssembly");
```

_Security Impact:_ Loading untrusted assemblies can lead to remote code execution.

---

**8.2 Dynamic type resolution with Type.GetType**

```regex
Type\.GetType\s*\(\s*".+?"\s*\)
```

_Explanation:_ Detects instances where types are looked up by name at runtime.  
_Example:_

```csharp
var type = Type.GetType("Namespace.ClassName, AssemblyName");
```

_Security Impact:_ May bypass compile-time checks and load unexpected types.

---

**8.3 Using Activator.CreateInstance unsafely**

```regex
Activator\.CreateInstance\s*\(\s*[^)]+\)
```

_Explanation:_ Flags calls that create objects dynamically, which could load malicious types.  
_Example:_

```csharp
object instance = Activator.CreateInstance(userProvidedType);
```

_Security Impact:_ Unvalidated dynamic instantiation may lead to execution of harmful code.

---

**8.4 Loading assemblies from files**

```regex
Assembly\.LoadFile\s*\(\s*[^)]+\)
```

_Explanation:_ Detects use of Assembly.LoadFile, which loads an assembly from a given file path.  
_Example:_

```csharp
Assembly asm = Assembly.LoadFile("C:\\temp\\malicious.dll");
```

_Security Impact:_ If the file path is influenced by user input, it can be exploited.

---

**8.5 Loading assemblies with Assembly.LoadFrom**

```regex
Assembly\.LoadFrom\s*\(\s*[^)]+\)
```

_Explanation:_ Similar to LoadFile, but may include additional path resolution.  
_Example:_

```csharp
Assembly asm = Assembly.LoadFrom(userProvidedPath);
```

_Security Impact:_ Dynamic loading from untrusted sources is a risk.

---

**8.6 Retrieving methods via reflection**

```regex
MethodInfo\s*\w*\s*=\s*type\.GetMethod\s*\(\s*".+?"\s*\)
```

_Explanation:_ Matches calls retrieving a method by name from a type.  
_Example:_

```csharp
MethodInfo method = type.GetMethod("ExecuteCommand");
```

_Security Impact:_ Incorrect or unsafe method selection can lead to unintended code execution.

---

**8.7 Instantiating objects via Activator**

```regex
object\s+\w+\s*=\s*Activator\.CreateInstance\s*\(\s*type\);
```

_Explanation:_ Captures object instantiation via Activator based on a type reference.  
_Example:_

```csharp
object obj = Activator.CreateInstance(someType);
```

_Security Impact:_ Dynamic instantiation can bypass type safety if not properly restricted.

---

**8.8 Using dynamic types with Activator**

```regex
dynamic\s+\w+\s*=\s*Activator\.CreateInstance\s*\(\s*[^)]+\)
```

_Explanation:_ Flags usage of dynamic object creation that could be manipulated by external input.  
_Example:_

```csharp
dynamic instance = Activator.CreateInstance(Type.GetType(userType));
```

_Security Impact:_ Leads to runtime errors or malicious code execution if misused.

---

**8.9 Deprecated Assembly.LoadWithPartialName usage**

```regex
Assembly\.LoadWithPartialName\s*\(\s*".+?"\s*\)
```

_Explanation:_ Detects use of the obsolete Assembly.LoadWithPartialName method.  
_Example:_

```csharp
var asm = Assembly.LoadWithPartialName("LegacyAssembly");
```

_Security Impact:_ This method is unreliable and may load unintended assemblies.

---

**8.10 AppDomain-based assembly loading**

```regex
AppDomain\.CurrentDomain\.Load\s*\(\s*".+?"\s*\)
```

_Explanation:_ Matches calls to load an assembly into the current AppDomain using a string name.  
_Example:_

```csharp
AppDomain.CurrentDomain.Load("InjectedAssembly");
```

_Security Impact:_ May allow attackers to force the loading of malicious assemblies.

---

## 9. Hardcoded Application Configuration Values

Exposing internal configuration values (such as environment settings or operational modes) can help attackers map your system. The regexes below search for hardcoded configuration settings.

**9.1 Direct assignment of configuration keywords**

```regex
(config|environment|mode)\s*=\s*"[^"]+"
```

_Explanation:_ Detects direct assignments to variables named “config”, “environment”, or “mode”.  
_Example:_

```csharp
string environment = "Production";
```

_Security Impact:_ Exposes internal deployment or configuration details.

---

**9.2 ConfigurationManager AppSettings assignment**

```regex
ConfigurationManager\.AppSettings\s*\[\s*"[A-Za-z0-9_]+"\s*\]\s*=\s*"[^"]+"
```

_Explanation:_ Matches assignments within the AppSettings section using ConfigurationManager.  
_Example:_

```csharp
ConfigurationManager.AppSettings["Mode"] = "Debug";
```

_Security Impact:_ Hardcoded settings can inadvertently reveal internal configuration.

---

**9.3 XML configuration add elements**

```regex
<add\s+key="(config|environment|mode)"\s+value="[^"]+"
```

_Explanation:_ Flags XML elements that set configuration values directly.  
_Example:_

```xml
<appSettings>
  <add key="environment" value="Staging" />
</appSettings>
```

_Security Impact:_ Reveals sensitive operational details.

---

**9.4 Environment variable retrieval**

```regex
var\s+\w+\s*=\s*Environment\.GetEnvironmentVariable\s*\(\s*".+?"\s*\)
```

_Explanation:_ Detects retrieval of environment variables that might be misused if hardcoded.  
_Example:_

```csharp
string env = Environment.GetEnvironmentVariable("APP_MODE");
```

_Security Impact:_ Although this is a read operation, hardcoding environment variable names may reveal deployment details.

---

**9.5 JSON configuration object with hardcoded values**

```regex
appSettings\s*:\s*\{\s*[^}]*("config"|"environment"|"mode")\s*:\s*".+?"
```

_Explanation:_ Matches JSON configuration files with hardcoded keys for environment settings.  
_Example:_

```json
{
  "appSettings": {
    "environment": "Production",
    "mode": "Release"
  }
}
```

_Security Impact:_ Exposes internal configuration that can be used in further attacks.

---

**9.6 Windows batch file environment settings**

```regex
set\s+ENVIRONMENT\s*=\s*".+"
```

_Explanation:_ Detects environment variable assignments in batch files.  
_Example:_

```batch
set ENVIRONMENT="Production"
```

_Security Impact:_ Hardcoded environment variables may reveal deployment details.

---

**9.7 Java VM argument for environment**

```regex
-Denv="[^"]+"
```

_Explanation:_ Matches command-line arguments that set environment variables for Java applications.  
_Example:_

```bash
java -Denv="Production" -jar app.jar
```

_Security Impact:_ Exposes configuration via startup arguments.

---

**9.8 Java VM argument for mode**

```regex
-Dmode="[^"]+"
```

_Explanation:_ Flags the use of mode-setting arguments in Java startup commands.  
_Example:_

```bash
java -Dmode="Debug" -jar app.jar
```

_Security Impact:_ Reveals runtime mode which may affect security posture.

---

**9.9 XML environment tag usage**

```regex
<environment>\s*[^<]+\s*</environment>
```

_Explanation:_ Identifies XML tags that explicitly declare the environment.  
_Example:_

```xml
<environment>Development</environment>
```

_Security Impact:_ Provides insight into system configuration.

---

**9.10 Custom configuration XML tags**

```regex
<configValue>\s*[^<]+\s*</configValue>
```

_Explanation:_ Catches non-standard XML configuration tags that might store sensitive settings.  
_Example:_

```xml
<configValue>Beta</configValue>
```

_Security Impact:_ Reveals internal operational details.

---

## 10. Insecure Deserialization

Deserialization of data from untrusted sources without proper validation can result in arbitrary code execution. The following regexes identify common deserialization patterns that require caution.

**10.1 BinaryFormatter deserialization**

```regex
BinaryFormatter\s*\.\s*Deserialize\s*\(
```

_Explanation:_ Detects calls to `BinaryFormatter.Deserialize`, which is high risk if the input is untrusted.  
_Example:_

```csharp
var obj = new BinaryFormatter().Deserialize(inputStream);
```

_Security Impact:_ Can lead to remote code execution if exploited.

---

**10.2 DataContractSerializer usage**

```regex
DataContractSerializer\s*\.\s*ReadObject\s*\(
```

_Explanation:_ Matches usage of DataContractSerializer for deserialization tasks.  
_Example:_

```csharp
var serializer = new DataContractSerializer(typeof(MyType));
var obj = serializer.ReadObject(xmlStream);
```

_Security Impact:_ Unsafe deserialization might enable injection attacks.

---

**10.3 XmlSerializer deserialization**

```regex
XmlSerializer\s*\.\s*Deserialize\s*\(
```

_Explanation:_ Identifies use of XmlSerializer to deserialize XML input.  
_Example:_

```csharp
var serializer = new XmlSerializer(typeof(MyData));
var data = serializer.Deserialize(fileStream);
```

_Security Impact:_ May allow crafted XML to exploit vulnerabilities in the type.

---

**10.4 JSON deserialization via JsonConvert**

```regex
JsonConvert\.DeserializeObject\s*\(
```

_Explanation:_ Detects JSON deserialization using popular libraries.  
_Example:_

```csharp
var obj = JsonConvert.DeserializeObject<UserData>(jsonString);
```

_Security Impact:_ Unsanitized JSON input can be a vector for injection.

---

**10.5 JavaScriptSerializer deserialization**

```regex
JavaScriptSerializer\s*\.\s*Deserialize\s*\(
```

_Explanation:_ Flags usage of the JavaScriptSerializer for deserialization tasks.  
_Example:_

```csharp
var serializer = new JavaScriptSerializer();
var result = serializer.Deserialize(jsonInput, typeof(MyType));
```

_Security Impact:_ Similar risks apply if the input is not trusted.

---

**10.6 NetDataContractSerializer deserialization**

```regex
NetDataContractSerializer\s*\.\s*Deserialize\s*\(
```

_Explanation:_ Catches use of NetDataContractSerializer, which can be very risky if untrusted data is provided.  
_Example:_

```csharp
var ndcs = new NetDataContractSerializer();
var obj = ndcs.Deserialize(stream);
```

_Security Impact:_ Can result in execution of unintended code.

---

**10.7 SoapFormatter deserialization**

```regex
SoapFormatter\s*\.\s*Deserialize\s*\(
```

_Explanation:_ Detects deserialization via the SoapFormatter class.  
_Example:_

```csharp
var formatter = new SoapFormatter();
var result = formatter.Deserialize(soapStream);
```

_Security Impact:_ Susceptible to similar exploitation as other deserialization methods.

---

**10.8 New BinaryFormatter instantiation with deserialization**

```regex
new\s+BinaryFormatter\s*\(\s*\)\.Deserialize\s*\(
```

_Explanation:_ More explicitly catches new BinaryFormatter objects used immediately for deserialization.  
_Example:_

```csharp
object data = new BinaryFormatter().Deserialize(networkStream);
```

_Security Impact:_ Directly exposes the code to deserialization vulnerabilities.

---

**10.9 Generic deserializer usage**

```regex
Deserializer\s*\.Deserialize\s*\(\s*[^)]+\)
```

_Explanation:_ Captures calls to a generic deserializer method that might be wrapping insecure deserialization.  
_Example:_

```csharp
var obj = Deserializer.Deserialize(inputData);
```

_Security Impact:_ The underlying deserialization mechanism may be insecure if not properly validated.

---

**10.10 DataContractJsonSerializer usage**

```regex
new\s+DataContractJsonSerializer\s*\(\s*typeof\([^)]*\)\s*\)\.ReadObject\s*\(
```

_Explanation:_ Flags instantiation of a JSON serializer using DataContractJsonSerializer for deserialization purposes.  
_Example:_

```csharp
var serializer = new DataContractJsonSerializer(typeof(Order));
var order = (Order)serializer.ReadObject(jsonStream);
```

_Security Impact:_ Unsafe deserialization may allow crafted JSON payloads to trigger code execution.

---

## 11. Insecure Use of Regular Expressions (ReDoS)

Poorly constructed regular expressions can be exploited for Regular Expression Denial of Service (ReDoS) attacks. The regexes below search for patterns and usages that might lead to performance issues.

**11.1 Basic new Regex instantiation**

```regex
new\s+Regex\s*\(\s*"[^"]+"\s*\)
```

_Explanation:_ Matches creation of new Regex objects from string literals.  
_Example:_

```csharp
var regex = new Regex("^(a+)+$");
```

_Security Impact:_ Certain regex patterns can be exploited to cause performance degradation.

---

**11.2 Regex.Match usage**

```regex
Regex\.Match\s*\(\s*[^,]+,\s*"[^"]+"\s*\)
```

_Explanation:_ Detects calls to Regex.Match where the pattern is hardcoded.  
_Example:_

```csharp
var match = Regex.Match(userInput, "^(a+)+$");
```

_Security Impact:_ May lead to ReDoS if the input is crafted to trigger worst-case behavior.

---

**11.3 Regex.IsMatch usage**

```regex
Regex\.IsMatch\s*\(\s*[^,]+,\s*"[^"]+"\s*\)
```

_Explanation:_ Flags usage of Regex.IsMatch with potentially unsafe patterns.  
_Example:_

```csharp
if (Regex.IsMatch(input, "^(\\d+)+$")) { ... }
```

_Security Impact:_ A maliciously crafted input can lead to excessive processing time.

---

**11.4 Regex.Replace usage with dynamic input**

```regex
Regex\.Replace\s*\(\s*[^,]+,\s*"[^"]+"\s*,\s*"[^"]*"\s*\)
```

_Explanation:_ Detects replacement operations that could be abused if the regex is complex.  
_Example:_

```csharp
var result = Regex.Replace(userInput, "^(x+)+y", "replacement");
```

_Security Impact:_ Poorly optimized patterns may cause denial of service.

---

**11.5 Specific vulnerable pattern example**

```regex
"(a\+)+\$"
```

_Explanation:_ Searches for specific patterns known to be ReDoS-prone.  
_Example:_

```csharp
var regex = new Regex("(a+)+$");
```

_Security Impact:_ These patterns can trigger catastrophic backtracking.

---

**11.6 Nested quantifier detection in Regex constructor**

```regex
new\s+Regex\s*\(\s*"(.*?)+?"\s*\)
```

_Explanation:_ Matches Regex constructors containing nested quantifiers that are typical ReDoS candidates.  
_Example:_

```csharp
var regex = new Regex("(.*?)+?");
```

_Security Impact:_ Such patterns may consume excessive CPU under attack.

---

**11.7 Vulnerable repetition pattern example**

```regex
"(x+)+y"
```

_Explanation:_ Identifies another common pattern that may lead to performance issues.  
_Example:_

```csharp
var regex = new Regex("(x+)+y");
```

_Security Impact:_ May result in a denial of service if exploited.

---

**11.8 Numeric repetition pattern example**

```regex
"(ab+)+c"
```

_Explanation:_ Catches patterns with nested repetition that are often vulnerable.  
_Example:_

```csharp
var regex = new Regex("(ab+)+c");
```

_Security Impact:_ Excessive backtracking can cripple performance.

---

**11.9 Another numeric example**

```regex
"(1+)+0"
```

_Explanation:_ Flags regex patterns with nested quantifiers on digits.  
_Example:_

```csharp
var regex = new Regex("(1+)+0");
```

_Security Impact:_ Can be used to mount ReDoS attacks.

---

**11.10 Regex.Compile usage**

```regex
Regex\.Compile\s*\(\s*"[^"]+"\s*\)
```

_Explanation:_ Detects the use of Regex.Compile with potentially unsafe patterns.  
_Example:_

```csharp
var compiledRegex = Regex.Compile("^(a+)+$");
```

_Security Impact:_ Even precompiled regexes can be abused if the underlying pattern is unsafe.

---

## 12. Insecure Inter-Process Communication (IPC)

Improperly secured IPC mechanisms can lead to interception or manipulation of inter-process communications. The following regexes help uncover risky IPC patterns.

**12.1 NamedPipeClientStream usage**

```regex
new\s+NamedPipeClientStream\s*\(\s*"[^"]+"\s*\)
```

_Explanation:_ Matches instantiation of NamedPipeClientStream objects with hardcoded pipe names.  
_Example:_

```csharp
var pipeClient = new NamedPipeClientStream("mypipe");
```

_Security Impact:_ Hardcoded pipe names may be targeted by attackers.

---

**12.2 NamedPipeServerStream usage**

```regex
new\s+NamedPipeServerStream\s*\(\s*"[^"]+"\s*,\s*\w+\s*\)
```

_Explanation:_ Detects NamedPipeServerStream creation with potential insecure configurations.  
_Example:_

```csharp
var pipeServer = new NamedPipeServerStream("mypipe", PipeDirection.InOut);
```

_Security Impact:_ Insecure pipe configurations may allow unauthorized access.

---

**12.3 TcpClient instantiation**

```regex
TcpClient\s+\w+\s*=\s*new\s+TcpClient\s*\(
```

_Explanation:_ Matches TcpClient objects being created from dynamic input.  
_Example:_

```csharp
TcpClient client = new TcpClient(remoteAddress, port);
```

_Security Impact:_ Without proper validation, attackers may redirect communications.

---

**12.4 TcpListener instantiation**

```regex
TcpListener\s+\w+\s*=\s*new\s+TcpListener\s*\(
```

_Explanation:_ Detects dynamic creation of TcpListener objects.  
_Example:_

```csharp
TcpListener listener = new TcpListener(IPAddress.Any, port);
```

_Security Impact:_ Insecure listeners can be exploited to intercept data.

---

**12.5 Socket instantiation**

```regex
Socket\s+\w+\s*=\s*new\s+Socket\s*\(
```

_Explanation:_ Matches direct creation of Socket objects.  
_Example:_

```csharp
Socket sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
```

_Security Impact:_ Sockets configured without proper security may leak sensitive data.

---

**12.6 UdpClient instantiation**

```regex
UdpClient\s+\w+\s*=\s*new\s+UdpClient\s*\(
```

_Explanation:_ Flags usage of UdpClient objects which may be used for unencrypted communications.  
_Example:_

```csharp
UdpClient udpClient = new UdpClient(port);
```

_Security Impact:_ Unsecured UDP communications can be intercepted.

---

**12.7 IPC channel creation**

```regex
new\s+IpcChannel\s*\(
```

_Explanation:_ Detects instantiation of IPC channels that might be used insecurely.  
_Example:_

```csharp
var channel = new IpcChannel(9090);
```

_Security Impact:_ Improper channel configuration may allow unauthorized message interception.

---

**12.8 Remoting TcpChannel registration**

```regex
System\.Runtime\.Remoting\.Channels\.TcpChannel\s*\(
```

_Explanation:_ Matches instantiation of a remoting TCP channel.  
_Example:_

```csharp
var channel = new System.Runtime.Remoting.Channels.TcpChannel(8080);
```

_Security Impact:_ May expose remote objects if not properly secured.

---

**12.9 Sockets via System.Net usage**

```regex
System\.Net\.Sockets\.Socket\s*\(
```

_Explanation:_ Detects lower-level socket instantiation via the System.Net.Sockets namespace.  
_Example:_

```csharp
var sock = new System.Net.Sockets.Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
```

_Security Impact:_ Unchecked socket operations can be exploited.

---

**12.10 Remoting service registration**

```regex
RemotingConfiguration\.RegisterWellKnownServiceType\s*\(
```

_Explanation:_ Flags the registration of well-known remoting services that could be exposed externally.  
_Example:_

```csharp
RemotingConfiguration.RegisterWellKnownServiceType(typeof(RemoteService), "RemoteService.rem", WellKnownObjectMode.Singleton);
```

_Security Impact:_ Insecurely exposed remoting services can provide a backdoor into the system.

---

## 13. Additional Vulnerabilities and Security Misconfigurations

Beyond the specific vulnerabilities above, code often contains commented-out sensitive data, debug artifacts, or insecure markers that warrant further review. The regexes below help pinpoint such areas.

**13.1 Commented-out sensitive keywords (single-line)**

```regex
\/\/\s*(password|secret|token|apikey|credential|connectionstring)\b.*$
```

_Explanation:_ Matches single-line comments that mention sensitive keywords.  
_Example:_

```csharp
// password = "TempPassword123"
```

_Security Impact:_ Even commented-out credentials can leak information.

---

**13.2 Commented-out sensitive keywords (multi-line)**

```regex
\/\*\s*(password|secret|token|apikey|credential|connectionstring)[\s\S]*?\*\/
```

_Explanation:_ Catches block comments containing sensitive keywords.  
_Example:_

```csharp
/* 
   secret = "OldSecretKey"
   Remove after testing.
*/
```

_Security Impact:_ Hidden secrets in comments may be recovered by attackers.

---

**13.3 Insecure TODO/FIXME/HACK markers**

```regex
\/\/\s*(TODO|FIXME|HACK)\b.*$
```

_Explanation:_ Identifies comments that indicate insecure or unfinished implementations.  
_Example:_

```csharp
// TODO: replace string concatenation with parameterized query
```

_Security Impact:_ These markers suggest that insecure practices might still be present.

---

**13.4 Insecure markers in script files (hash comments)**

```regex
#\s*(TODO|FIXME|HACK)\b.*$
```

_Explanation:_ Matches similar insecure markers in languages that use hash comments (e.g., Python, Bash).  
_Example:_

```python
# FIXME: hardcoded password found here
```

_Security Impact:_ Indicates areas that require further security review.

---

**13.5 Debug mode enabled in configuration**

```regex
debug\s*=\s*true
```

_Explanation:_ Detects configuration files or code where debug mode is explicitly enabled.  
_Example:_

```xml
<appSettings>
  <add key="debug" value="true"/>
</appSettings>
```

_Security Impact:_ Debug mode may leak internal details to an attacker.

---

**13.6 Verbose logging enabled**

```regex
\bverbose\s*=\s*true\b
```

_Explanation:_ Matches configuration settings that enable verbose logging.  
_Example:_

```json
{
  "logging": {
    "verbose": true
  }
}
```

_Security Impact:_ Verbose logs can include sensitive information and assist attackers.

---

**13.7 Hardcoded server names in configurations**

```regex
server\s*=\s*"localhost"
```

_Explanation:_ Detects hardcoded server names that might reveal testing environments.  
_Example:_

```csharp
string dbServer = "localhost";
```

_Security Impact:_ Reveals that the code might still be configured for non-production environments.

---

**13.8 Debug/tracing comments in SQL scripts**

```regex
--\s*(debug|trace)
```

_Explanation:_ Flags SQL comments that indicate debug or trace statements.  
_Example:_

```sql
-- trace: temporary log for debugging query performance
```

_Security Impact:_ Debugging artifacts may expose sensitive SQL logic.

---

**13.9 XML debug mode tags**

```regex
<debugMode>\s*true\s*<\/debugMode>
```

_Explanation:_ Searches for XML tags that enable debug mode.  
_Example:_

```xml
<debugMode>true</debugMode>
```

_Security Impact:_ Activates internal debugging that could be exploited.

---

**13.10 Preprocessor directives enabling debug features**

```regex
ENABLE_DEBUG\s*=\s*true
```

_Explanation:_ Matches preprocessor or build configuration settings that enable debug features.  
_Example:_

```c
#define ENABLE_DEBUG true
```

_Security Impact:_ Debug features may inadvertently expose internal application state.