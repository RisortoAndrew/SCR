# **Comprehensive Cheat Sheet for Identifying Command Injection Vulnerabilities in C# Applications**

---

**Table of Contents**

1. [Introduction to Command Injection](https://chatgpt.com/c/674f62fd-d3ec-8013-bbe1-f940367ab8f7#introduction)
2. [Common Vulnerable Patterns in C#](https://chatgpt.com/c/674f62fd-d3ec-8013-bbe1-f940367ab8f7#vulnerable-patterns)
3. [Regex Patterns for Detection](https://chatgpt.com/c/674f62fd-d3ec-8013-bbe1-f940367ab8f7#regex-patterns)
4. [Detailed Examples and Explanations](https://chatgpt.com/c/674f62fd-d3ec-8013-bbe1-f940367ab8f7#examples)
5. [Interpreting and Validating Findings](https://chatgpt.com/c/674f62fd-d3ec-8013-bbe1-f940367ab8f7#interpreting-findings)
6. [Best Practices for Prevention](https://chatgpt.com/c/674f62fd-d3ec-8013-bbe1-f940367ab8f7#prevention)
7. [Additional Resources](https://chatgpt.com/c/674f62fd-d3ec-8013-bbe1-f940367ab8f7#resources)

---

## **1. Introduction to Command Injection**

**Command Injection** is a critical security vulnerability that occurs when an application incorporates untrusted input into system commands. In C# applications, this often happens when executing shell commands using methods like `Process.Start()` with user-supplied data. Attackers can exploit this to execute arbitrary commands on the server, leading to unauthorized access, data theft, or complete system compromise.

Understanding how to identify and mitigate command injection vulnerabilities is essential for developers and security professionals to ensure the safety and integrity of applications.

---

## **2. Common Vulnerable Patterns in C#**

Vulnerable patterns in C# applications that can lead to command injection include:

- **Using `Process.Start()` with Untrusted Input**: Directly passing user input into methods that execute system commands.
- **Dynamic Command Construction**: Building command strings through concatenation or interpolation that include user-supplied data.
- **Use of `System.Diagnostics.ProcessStartInfo` with Untrusted Arguments**: Configuring `ProcessStartInfo` with user input without proper validation.
- **Shell Execution via `cmd.exe` or `/bin/bash`**: Invoking shell interpreters and passing commands that include user input.
- **Improper Input Validation and Sanitization**: Failing to properly validate or sanitize user input before using it in system commands.
- **External Libraries or APIs**: Using third-party libraries that execute system commands with unvalidated user input.

---

## **3. Regex Patterns for Detection**

Below are regex patterns designed to identify potential command injection points in C# code. These patterns are compatible with Visual Studio Code's global search functionality.

### **3.1. Usage of `Process.Start()` with Untrusted Input**

**Pattern**:

```regex
Process\.Start\s*\(\s*([^\);]+)\s*\)
```

**Explanation**:

- Detects calls to `Process.Start()` with any arguments.
- Captures the arguments passed to the `Start()` method.

### **3.2. Usage of `ProcessStartInfo` with Untrusted Input**

**Pattern**:

```regex
new\s+ProcessStartInfo\s*\(\s*([^\);]+)\s*\)
```

**Explanation**:

- Finds instances where `ProcessStartInfo` is instantiated.
- Captures the arguments passed to the constructor.

### **3.3. Concatenation or Interpolation of Command Strings**

**Pattern**:

```regex
(["'].*["']\s*\+\s*\w+|\$".*\{.*\}.*")
```

**Explanation**:

- Identifies string concatenations or interpolations that include variables (potentially user input).
- Useful for detecting dynamic command construction.

### **3.4. Invoking Shell Commands via `cmd.exe` or `bash`**

**Pattern**:

```regex
Process\.Start\s*\(\s*["'](cmd\.exe|/bin/bash)["'],\s*([^\);]+)\s*\)
```

**Explanation**:

- Captures calls to `Process.Start()` that invoke shell interpreters with arguments.
- Highlights potential execution of shell commands with user input.

### **3.5. External Library Calls Executing Commands**

**Pattern**:

```regex
ShellExecute\s*\(\s*([^\);]+)\s*\)
```

**Explanation**:

- Detects usage of methods like `ShellExecute` that may execute system commands.
- Captures the arguments to analyze for untrusted input.

---

## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: Using `Process.Start()` with User Input**

```csharp
string command = Request.QueryString["command"];
Process.Start(command);
```

**Why It's Vulnerable**:

- The application executes whatever command the user provides without validation.
- An attacker can execute arbitrary system commands.

**Regex Match Explanation**:

- The pattern matches `Process.Start(command)` and captures `command` as the argument.

### **4.2. Vulnerable Code Example: `ProcessStartInfo` with Untrusted Arguments**

```csharp
string filename = Request.Form["filename"];
var psi = new ProcessStartInfo("notepad.exe", filename);
Process.Start(psi);
```

**Why It's Vulnerable**:

- `filename` comes from user input and is used as an argument.
- An attacker can manipulate the filename to execute unintended commands or access unauthorized files.

**Regex Match Explanation**:

- The regex identifies the instantiation of `ProcessStartInfo` with parameters that may include user input.

### **4.3. Vulnerable Code Example: String Concatenation in Command Execution**

```csharp
string userInput = Request.QueryString["dir"];
string cmd = "/C dir " + userInput;
Process.Start("cmd.exe", cmd);
```

**Why It's Vulnerable**:

- User input `userInput` is concatenated into the command string.
- Allows command injection via special characters or command separators.

**Regex Match Explanation**:

- The pattern detects string concatenation involving `userInput` in the command arguments.

### **4.4. Vulnerable Code Example: Shell Command Execution**

```csharp
string scriptName = Request.Form["script"];
Process.Start("/bin/bash", scriptName);
```

**Why It's Vulnerable**:

- The application runs a script specified by the user.
- An attacker can execute arbitrary scripts or commands.

**Regex Match Explanation**:

- The regex captures the use of `Process.Start()` with potential shell execution.

### **4.5. Vulnerable Code Example: External Library Command Execution**

```csharp
string cmd = Request.QueryString["cmd"];
SomeLibrary.ShellExecute(cmd);
```

**Why It's Vulnerable**:

- The method `ShellExecute` may execute system commands with untrusted input.
- The implementation may not sanitize or validate the input.

**Regex Match Explanation**:

- The regex detects calls to `ShellExecute()` with arguments that may include user input.

---

## **5. Interpreting and Validating Findings**

- **Trace User Input**: Confirm that the data used in system commands originates from untrusted sources like `Request.QueryString`, `Request.Form`, or other user inputs.
- **Analyze Command Construction**: Check how the command string is constructed. Look for concatenation, interpolation, or formatting that includes user input.
- **Review Method Calls**: Ensure that methods like `Process.Start()` are not used with unvalidated input.
- **Consider the Execution Context**: Determine if the executed commands run with elevated privileges, which increases the risk.

**Example**:

- If `command` is derived from a hard-coded string or a secure configuration file, the risk is lower.
- If `command` includes any form of user input without proper validation or sanitization, it's a significant vulnerability.

---

## **6. Best Practices for Prevention**

### **6.1. Avoid Executing System Commands with User Input**

- **Recommendation**: Refrain from using `Process.Start()` with user-supplied data.
- **Alternative**: Use built-in .NET APIs or libraries to achieve the desired functionality.

**Example**:

- Instead of executing a shell command to list files, use `System.IO` namespace methods.

```csharp
string[] files = Directory.GetFiles(safeDirectoryPath);
```

### **6.2. Input Validation and Whitelisting**

- **Validate Input**: Ensure that user input meets expected patterns or values.
- **Whitelisting**: Allow only specific, known-good inputs (e.g., command names from a predefined list).

**Example**:

```csharp
List<string> allowedCommands = new List<string> { "notepad.exe", "calc.exe" };
string command = Request.QueryString["command"];

if (allowedCommands.Contains(command))
{
    Process.Start(command);
}
else
{
    throw new ArgumentException("Invalid command");
}
```

### **6.3. Use Parameterized Arguments**

- **Avoid Shell Interpretation**: Use `ProcessStartInfo` with arguments passed separately to prevent shell injection.

**Safe Example**:

```csharp
string userInput = Request.QueryString["filename"];
string safeFileName = Path.GetFileName(userInput); // Ensure it's just a filename
var psi = new ProcessStartInfo("notepad.exe", safeFileName);
Process.Start(psi);
```

- **Note**: Ensure that `userInput` does not contain directory traversal characters or other malicious patterns.

### **6.4. Escape or Sanitize User Input**

- **Sanitize Input**: Remove or encode characters that can alter command structure (e.g., `&`, `|`, `;`).

**Example**:

```csharp
string userInput = Request.QueryString["dir"];
userInput = Regex.Replace(userInput, @"[&|;]", "");
string cmd = "/C dir " + userInput;
Process.Start("cmd.exe", cmd);
```

- **Caution**: Sanitization can be error-prone. Whitelisting is more secure.

### **6.5. Least Privilege Principle**

- **Run with Limited Permissions**: Ensure that the application and any executed commands run with the minimal necessary privileges.

**Example**:

```csharp
var psi = new ProcessStartInfo("notepad.exe")
{
    UseShellExecute = false,
    UserName = "limitedUser",
    Password = secureStringPassword,
    Domain = "DOMAIN"
};
Process.Start(psi);
```

### **6.6. Avoid Shell Execution**

- **Recommendation**: Avoid invoking shell interpreters like `cmd.exe` or `/bin/bash`.

**Example**:

- Instead of executing `cmd.exe` to run a command, use native C# methods or system APIs.

### **6.7. Security Libraries and Tools**

- **Use Security Frameworks**: Implement libraries that provide secure execution environments or sandboxing.
- **Static Code Analysis**: Utilize tools that can detect command injection vulnerabilities in code.

### **6.8. Implement Safe File Paths**

- **Prevent Directory Traversal**: Use methods like `Path.GetFileName()` to extract the filename and prevent directory traversal.

**Example**:

```csharp
string userInput = Request.QueryString["file"];
string safeFileName = Path.GetFileName(userInput);
string fullPath = Path.Combine(safeDirectoryPath, safeFileName);
```

---

## **7. Additional Resources**

- **OWASP Command Injection Cheat Sheet**: [Link](https://cheatsheetseries.owasp.org/cheatsheets/Command_Injection.html)
- **Microsoft Secure Coding Guidelines**: [Link](https://docs.microsoft.com/en-us/dotnet/standard/security/secure-coding-guidelines)
- **CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')**: [Link](https://cwe.mitre.org/data/definitions/78.html)
- **Official Documentation**:
    - **Process.Start Method**: [Link](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start)
    - **ProcessStartInfo Class**: [Link](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.processstartinfo)
    - **Secure String Handling**: [Link](https://docs.microsoft.com/en-us/dotnet/standard/security/secure-string-handling)

---

**Disclaimer**: This cheat sheet is intended for educational purposes to help developers identify and fix security vulnerabilities in their own applications. Always ensure you have proper authorization before conducting security testing.

---

**Final Notes**:

- **Understand the Risks**: Command injection vulnerabilities can lead to complete system compromise.
- **Regular Code Reviews**: Incorporate security reviews focused on areas where system commands are executed.
- **Security Training**: Educate development teams about the dangers of command injection and secure coding practices.
- **Automated Tools**: Use static analysis tools that can detect command injection vulnerabilities.

By diligently applying these guidelines and using the regex patterns provided, you can effectively identify and mitigate command injection vulnerabilities in your C# applications.

---

## **Appendix: Additional Regex Patterns and Explanations**

### **A.1. Detecting Unsafe Shell Command Invocations**

**Pattern**:

```regex
Process\.Start\s*\(\s*["'](cmd\.exe|powershell\.exe)["']\s*,\s*([^\);]+)\s*\)
```

**Explanation**:

- Specifically targets calls to `Process.Start()` that execute `cmd.exe` or `powershell.exe`.
- Captures the command-line arguments, which may include untrusted input.

### **A.2. Identifying String Interpolation with User Input**

**Pattern**:

```regex
\$\".*\{.*Request\.(QueryString|Form)\[.*\].*\}.*\"
```

**Explanation**:

- Detects interpolated strings that include user input from `Request.QueryString` or `Request.Form`.
- Highlights potential places where user input is embedded directly into command strings.

### **A.3. Finding `ProcessStartInfo` with Untrusted File Names**

**Pattern**:

```regex
new\s+ProcessStartInfo\s*\(\s*["'][^"']*["']\s*,\s*Request\.(QueryString|Form)\[.*\]\s*\)
```

**Explanation**:

- Identifies instances where `ProcessStartInfo` is created with arguments from user input.
- Useful for spotting potential file execution or opening vulnerabilities.

---

## **Tips for Effective Code Scanning**

- **Combine Regex Patterns**: Use multiple regex patterns to cover different scenarios.
- **Review Matches Carefully**: Not all matches indicate vulnerabilities; some may be false positives.
- **Automate Scanning**: Integrate regex patterns into automated code analysis tools for continuous monitoring.
- **Stay Updated**: Regularly update regex patterns and scanning tools to adapt to new coding practices and frameworks.