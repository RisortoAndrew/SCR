## **1. Introduction to Web Cache Poisoning & Web Cache Deception**

**Web Cache Poisoning** and **Web Cache Deception** vulnerabilities occur when an attacker is able to inject malicious content or manipulate caching headers so that sensitive or dynamic data is cached (or served) to unauthorized users. In C# applications—especially those built on ASP.NET—these issues often result from insecure configuration of caching headers and output caching mechanisms. The consequences include:

- **Exposure of Sensitive Data**: Private or user-specific information cached publicly.
- **Cache Poisoning**: An attacker manipulates cache entries so that later users receive attacker-controlled content.
- **Cache Deception**: Improperly cached error pages or dynamic content may be served to unintended users.
- **Bypassing Authorization**: Cached responses might bypass proper authentication if not isolated per user.

Understanding and mitigating these issues is critical for securing web applications.

---

## **2. Common Vulnerable Patterns in C#**

C# applications are at risk when caching directives are misapplied. Common vulnerable patterns include:

- **Public Caching of Sensitive Responses**: Using `HttpCacheability.Public` on responses that contain sensitive or dynamic data.
- **Insecure Header Manipulation**: Explicitly adding headers like `Cache-Control: public` or setting `Vary: *` without proper controls.
- **Misconfigured OutputCache Attributes**: Using attributes (e.g., `[OutputCache]`) with overly permissive parameters such as `VaryByParam="*"` or insecure cache profiles.
- **Long Cache Expiration Times**: Setting expiration dates far into the future.
- **Dynamic Cache Settings via Variables**: Relying on variables or external input to determine cache behavior.
- **Direct Header Injection**: Direct use of `Response.AddHeader` to set caching headers without validation.

---

## **3. Regex Patterns for Detection**

Below are ten VS‑Code compatible regex patterns designed to help you locate potential Web Cache Poisoning and Web Cache Deception vulnerabilities in C# code. Use these patterns with your IDE’s global search functionality.

### **3.1. Detecting Public Cacheability Setting via Response.Cache**

```regex
Response\.Cache\.SetCacheability\s*\(\s*HttpCacheability\.Public\s*\)
```

_Explanation_:  
Flags code that sets response cacheability to Public, which is risky if sensitive data is involved.

---

### **3.2. Detecting Direct Addition of a "Cache-Control: public" Header**

```regex
Response\.AddHeader\s*\(\s*"Cache-Control"\s*,\s*"public"\s*\)
```

_Explanation_:  
Identifies when the Cache-Control header is explicitly set to "public" via Response.AddHeader.

---

### **3.3. Detecting a Wildcard Vary Header**

```regex
Response\.AddHeader\s*\(\s*"Vary"\s*,\s*"\*"\s*\)
```

_Explanation_:  
Captures cases where a Vary header is set to "*"—an insecure configuration that can cause unpredictable caching behavior.

---

### **3.4. Direct Header Assignment of "Cache-Control" via Response.Headers**

```regex
Response\.Headers\["Cache-Control"\]\s*=\s*".*public.*"
```

_Explanation_:  
Matches direct assignment to the Cache-Control header that includes the term "public", even if assembled dynamically.

---

### **3.5. Insecure OutputCache Attribute with VaryByParam Set to "*"**

```regex
\[OutputCache\s*\(\s*Duration\s*=\s*\d+\s*,\s*VaryByParam\s*=\s*".*"\s*\)\]
```

_Explanation_:  
Detects the use of the OutputCache attribute with a Duration and VaryByParam parameter—especially when VaryByParam is permissively set (e.g., "*").

---

### **3.6. Detecting Long-Lived Expiration Settings via SetExpires**

```regex
Response\.Cache\.SetExpires\s*\(\s*DateTime\.Now\.Add(Seconds|Minutes|Hours)\s*\(
```

_Explanation_:  
Finds code that sets an expiration time relative to the current time. Expiring far into the future may lead to stale or poisoned cache entries.

---

### **3.7. Usage of SetValidUntilExpires with a True Value**

```regex
Response\.Cache\.SetValidUntilExpires\s*\(\s*true\s*\)
```

_Explanation_:  
Matches instances where responses are validated until they expire, which, if misapplied, may extend the lifetime of cached sensitive data.

---

### **3.8. Detecting Direct Addition of an Expires Header**

```regex
Response\.AddHeader\s*\(\s*"Expires"\s*,\s*".*"\s*\)
```

_Explanation_:  
Catches direct manipulation of the Expires header, which—if hardcoded—can result in insecure caching behavior.

---

### **3.9. Detecting Variable-Based Cacheability Settings**

```regex
Response\.Cache\.SetCacheability\s*\(\s*\w+\s*\)
```

_Explanation_:  
Identifies cases where the cacheability is set via a variable rather than a fixed value, which might be insecure if the variable’s source is untrusted.

---

### **3.10. Detecting OutputCache Attribute Referencing a CacheProfile**

```regex
\[OutputCache\s*\(\s*CacheProfile\s*=\s*".*"\s*\)\]
```

_Explanation_:  
Matches the use of an OutputCache attribute that specifies a CacheProfile. Misconfigured profiles can lead to public caching of sensitive pages.

---

## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: Public Cacheability**

```csharp
// Example: Insecure caching configuration that may poison the cache
Response.Cache.SetCacheability(HttpCacheability.Public);
Response.Cache.SetExpires(DateTime.Now.AddHours(1));
Response.Cache.SetValidUntilExpires(true);
Response.Write("Sensitive user data");
```

**Why It's Vulnerable**:  
Marking the response as public with a long expiration and enabling validation until expiration can cause sensitive data to be cached and later served to unauthorized users.

**Regex Match Explanation**:  
Matches patterns **3.1**, **3.6**, and **3.7**.

---

### **4.2. Vulnerable Code Example: Insecure Header Injection**

```csharp
// Example: Directly setting insecure caching headers
Response.AddHeader("Cache-Control", "public, max-age=3600");
Response.AddHeader("Expires", "Fri, 01 Jan 2100 00:00:00 GMT");
Response.AddHeader("Vary", "*");
```

**Why It's Vulnerable**:  
Explicitly adding headers that allow public caching (and using a wildcard Vary header) can result in cache poisoning or deception, as the cache may serve sensitive data to unintended users.

**Regex Match Explanation**:  
Matches patterns **3.2**, **3.3**, and **3.8**.

---

### **4.3. Vulnerable Code Example: Misconfigured OutputCache Attribute**

```csharp
// Example: Vulnerable use of OutputCache attribute in an MVC action
[OutputCache(Duration = 3600, VaryByParam = "*")]
public ActionResult AccountDetails() {
    // Returns sensitive account information
    return View();
}
```

**Why It's Vulnerable**:  
Using VaryByParam set to "*" fails to differentiate between parameters properly, allowing cache poisoning and cache deception attacks by serving cached data across users.

**Regex Match Explanation**:  
Matches patterns **3.5** and **3.10**.

---

### **4.4. Vulnerable Code Example: Variable-Based Cache Setting**

```csharp
// Example: Cacheability determined by a variable that might be insecure
var cachePolicy = GetCachePolicyFromUserInput(); // May return HttpCacheability.Public
Response.Cache.SetCacheability(cachePolicy);
```

**Why It's Vulnerable**:  
If the variable `cachePolicy` is influenced by untrusted sources, it could inadvertently set the response to be publicly cached, exposing sensitive data.

**Regex Match Explanation**:  
Matches pattern **3.9**.

---

### **4.5. Vulnerable Code Example: Insecure CacheProfile Usage**

```csharp
// Example: OutputCache attribute referencing a potentially misconfigured CacheProfile
[OutputCache(CacheProfile = "PublicProfile")]
public ActionResult Dashboard() {
    // Returns dashboard data intended for a single user
    return View();
}
```

**Why It's Vulnerable**:  
If the CacheProfile "PublicProfile" is defined in web.config with permissive settings (e.g., public caching), it may lead to sensitive data being cached and served across sessions.

**Regex Match Explanation**:  
Matches pattern **3.10**.

---

## **5. Interpreting and Validating Findings**

- **Review Cache Settings**: Confirm whether responses containing sensitive data are improperly marked for public caching.
- **Examine Data Flow**: Trace how caching headers are set—ensure that user-specific or dynamic content is not cached.
- **Evaluate Impact**: Determine the risk associated with publicly cached data, including cache poisoning and deception scenarios.
- **Cross-Reference Configurations**: Verify that cache profiles in configuration files (e.g., web.config) enforce strict controls.
- **Test Scenarios**: Simulate requests with manipulated parameters to see if cached responses reveal sensitive information.

---

## **6. Best Practices for Prevention**

### **6.1. Secure Cache Configuration**

- **Use Private or No-Store Cacheability**: For sensitive content, set cacheability to `HttpCacheability.Private` or disable caching altogether.
- **Implement Strict Expiration Policies**: Avoid setting expiration dates far into the future for dynamic content.

**Example**:

```csharp
Response.Cache.SetCacheability(HttpCacheability.Private);
Response.Cache.SetNoStore(true);
```

---

### **6.2. Configure OutputCache Attributes Carefully**

- **Limit VaryByParam**: Avoid using wildcards; specify only the parameters that genuinely affect the response.
- **Employ Secure Cache Profiles**: Define cache profiles in web.config with rigorous rules for sensitive endpoints.

**Example**:

```csharp
[OutputCache(Duration = 60, VaryByParam = "id")]
public ActionResult UserProfile(int id) {
    return View();
}
```

---

### **6.3. Validate and Sanitize Cache Headers**

- **Centralize Cache Management**: Use a common utility to set caching headers, ensuring consistency across the application.
- **Audit Header Values**: Regularly review header values (e.g., Cache-Control, Expires, Vary) to prevent insecure configurations.

**Example**:

```csharp
Response.AddHeader("Cache-Control", "private, max-age=60");
Response.AddHeader("Vary", "Accept-Encoding");
```