## **1. Introduction to SSRF in C#**

**Server-Side Request Forgery (SSRF)** is a vulnerability in which an attacker tricks a server-side application into making network requests to an unintended destination. In C# applications, this often occurs when user-supplied URLs or hostnames are used directly in network request functions without proper validation. An attacker can leverage SSRF to:

- **Bypass Network Restrictions**: Access internal systems or services that are normally inaccessible from the internet.
- **Expose Sensitive Data**: Retrieve data from internal resources such as metadata services or private APIs.
- **Perform Port Scanning**: Discover and exploit internal network services.
- **Cause Denial of Service (DoS)**: Overwhelm internal services or trigger unintended behavior.
- **Potential Remote Code Execution**: In certain configurations, SSRF can even lead to remote code execution.

Identifying SSRF vulnerabilities is critical for safeguarding internal network resources and preventing data breaches.

---

## **2. Common Vulnerable Patterns in C#**

In C# applications, SSRF vulnerabilities often arise from patterns such as:

- **Direct Use of User Input in Network Calls**: Using request parameters (e.g., via `Request.QueryString`, `Request.Params`, or indexers like `Request["url"]`) directly when constructing network requests.
- **Dynamic URL Construction**: Building URLs by concatenating user input with fixed strings (e.g., base URLs).
- **Unvalidated Instantiation of Uri Objects**: Creating `Uri` objects directly from user-supplied data.
- **Use of Legacy HTTP Classes**: Utilizing classes like `WebRequest`, `HttpWebRequest`, or `WebClient` without proper input sanitization.
- **HttpClient Misuse**: Using `HttpClient` or its methods (e.g., `GetAsync`, `SendAsync`) with untrusted URL parameters.
- **DNS Resolution from User Input**: Direct calls to `Dns.GetHostEntry` or similar methods based on user input, which can lead to DNS rebinding attacks.

---

## **3. Regex Patterns for Detection**

Below are ten VS‑Code compatible regex patterns (without inline case‑insensitivity) designed to help identify potential SSRF vulnerabilities in C# source code. Use these patterns in your IDE’s global search to manually review the codebase.

### **3.1. Direct Instantiation of Uri with Request Indexer**

```regex
new\s+Uri\s*\(\s*Request\[\s*["'](url|uri|endpoint)["']\s*\]\s*\)
```

_Explanation_:  
Matches the creation of a new `Uri` object where the URL is directly retrieved from `Request["url"]`, `Request["uri"]`, or `Request["endpoint"]`.

---

### **3.2. Instantiation of Uri with Request.QueryString**

```regex
new\s+Uri\s*\(\s*Request\.QueryString\s*\(\s*["'](url|uri|endpoint)["']\s*\)\s*\)
```

_Explanation_:  
Detects `Uri` creation using a URL obtained from `Request.QueryString`, indicating direct user input.

---

### **3.3. Use of WebRequest.Create with Request Indexer**

```regex
WebRequest\.Create\s*\(\s*Request\[\s*["'](url|uri|endpoint)["']\s*\]\s*\)
```

_Explanation_:  
Flags code where `WebRequest.Create` is called with a URL derived from `Request["url"]`, suggesting an SSRF risk.

---

### **3.4. WebClient.DownloadString Using User Input**

```regex
new\s+WebClient\s*\(\s*\)\.DownloadString\s*\(\s*Request\[\s*["'](url|uri|endpoint)["']\s*\]\s*\)
```

_Explanation_:  
Matches instances where a new `WebClient` is used to download data directly from a user-supplied URL.

---

### **3.5. HttpClient.GetAsync with User-Supplied URL**

```regex
GetAsync\s*\(\s*Request\[\s*["'](url|uri|endpoint)["']\s*\]\s*\)
```

_Explanation_:  
Captures calls to `GetAsync` on an `HttpClient` object that use a URL from a request parameter, indicating potential SSRF.

---

### **3.6. Assignment of Request Parameter to a Variable**

```regex
string\s+\w+\s*=\s*Request\[\s*["'](url|uri|endpoint)["']\s*\];
```

_Explanation_:  
Detects when a string variable is assigned directly from `Request["url"]` (or similar), which may later be used in network requests.

---

### **3.7. Concatenated URL Construction with Request Parameter**

```regex
new\s+Uri\s*\(\s*".*"\s*\+\s*Request\[\s*["'](url|uri|endpoint)["']\s*\]\s*\)
```

_Explanation_:  
Matches cases where a base URL (as a string literal) is concatenated with a user-supplied value to form a full URL, a common SSRF pattern.

---

### **3.8. WebRequest.Create Using a Variable Named with “url”**

```regex
WebRequest\.Create\s*\(\s*\w*(url|uri|endpoint)\w*\s*\)
```

_Explanation_:  
Catches usage of `WebRequest.Create` where the argument is a variable whose name includes “url”, “uri”, or “endpoint”, hinting that it might originate from user input.

---

### **3.9. HttpClient.SendAsync with User-Supplied HttpRequestMessage**

```regex
SendAsync\s*\(\s*new\s+HttpRequestMessage\s*\(\s*HttpMethod\.[A-Za-z]+\s*,\s*Request\[\s*["'](url|uri|endpoint)["']\s*\]\s*\)
```

_Explanation_:  
Identifies the creation of an `HttpRequestMessage` using a method (e.g., `HttpMethod.Get`) and a URL directly from a request parameter within `SendAsync`.

---

### **3.10. Instantiation of Uri with Request.Params**

```regex
new\s+Uri\s*\(\s*Request\.Params\s*\(\s*["'](url|uri|endpoint)["']\s*\)\s*\)
```

_Explanation_:  
Finds cases where `Request.Params` is used to obtain a URL for constructing a `Uri` object, another indicator of SSRF risk.

---

## **4. Detailed Examples and Explanations**

### **4.1. Vulnerable Code Example: Direct Uri Instantiation**

```csharp
// Vulnerable: Directly using user input to create a Uri
string imageUrl = Request["url"];
Uri uri = new Uri(imageUrl);
WebRequest request = WebRequest.Create(uri);
WebResponse response = request.GetResponse();
// Process the response stream...
```

**Why It's Vulnerable**:  
The URL is taken directly from user input without any validation, allowing an attacker to supply a URL that targets internal resources.

---

### **4.2. Vulnerable Code Example: WebClient with User Input**

```csharp
// Vulnerable: Using WebClient to fetch data from a user-supplied URL
string apiEndpoint = Request["endpoint"];
string result = new WebClient().DownloadString(apiEndpoint);
// Process the downloaded data...
```

**Why It's Vulnerable**:  
An attacker can control the `apiEndpoint` parameter, forcing the server to request data from unintended or malicious destinations.

---

### **4.3. Vulnerable Code Example: HttpClient.GetAsync Misuse**

```csharp
// Vulnerable: HttpClient making asynchronous call with unvalidated user input
string externalUrl = Request.QueryString("uri");
HttpClient client = new HttpClient();
Task<HttpResponseMessage> responseTask = client.GetAsync(externalUrl);
HttpResponseMessage response = responseTask.Result;
// Process the response...
```

**Why It's Vulnerable**:  
Directly using a URL from `Request.QueryString` without validating its host or protocol exposes the application to SSRF attacks.

---

### **4.4. Vulnerable Code Example: URL Concatenation**

```csharp
// Vulnerable: Concatenating a base URL with a user-supplied parameter
string baseUrl = "https://api.example.com/data?query=";
string userQuery = Request["uri"];
Uri fullUri = new Uri(baseUrl + userQuery);
WebRequest request = WebRequest.Create(fullUri);
WebResponse response = request.GetResponse();
// Process response...
```

**Why It's Vulnerable**:  
The attacker can manipulate the `userQuery` parameter to alter the destination URL or inject additional parameters, leading to SSRF.

---

### **4.5. Vulnerable Code Example: Using Request.Params**

```csharp
// Vulnerable: Using Request.Params to build a network request
string targetUrl = Request.Params("endpoint");
Uri uri = new Uri(targetUrl);
HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(uri);
HttpWebResponse webResponse = (HttpWebResponse)webRequest.GetResponse();
// Handle the response...
```

**Why It's Vulnerable**:  
Using `Request.Params` to fetch the URL without any restrictions allows attackers to provide URLs that might target internal systems.

---

## **5. Interpreting and Validating Findings**

- **Trace the Data Flow**: Verify where the URL originates and ensure it is not tainted by untrusted user input.
- **Review Validation Mechanisms**: Check for any input validation or sanitization routines that confirm the URL conforms to allowed formats or domains.
- **Assess Domain Restrictions**: Determine if the application limits requests to whitelisted domains or IP ranges.
- **Understand Contextual Usage**: Not every match indicates a vulnerability; sometimes user input is validated elsewhere in the code.
- **Test with Malicious Inputs**: Consider how an attacker might supply a URL that bypasses any validation (e.g., via encoded characters, alternate protocols, or DNS rebinding techniques).

---

## **6. Best Practices for Prevention**

### **6.1. Never Trust User Input Directly**

- **Always Validate**: Never pass user-supplied URLs or hostnames directly to network functions.
- **Sanitize Input**: Apply strict validation (e.g., using regular expressions or built-in URI validation) to ensure the URL is well-formed.

**Example**:

```csharp
string url = Request["url"];
if (!Uri.TryCreate(url, UriKind.Absolute, out Uri validatedUri))
{
    throw new ArgumentException("Invalid URL");
}
```

---

### **6.2. Implement Whitelisting**

- **Allow Only Known Domains**: Maintain a whitelist of permitted domains or IP ranges and reject all others.

**Example**:

```csharp
List<string> allowedHosts = new List<string> { "api.example.com", "images.example.com" };
if (!allowedHosts.Contains(validatedUri.Host))
{
    throw new SecurityException("Access to the specified domain is not allowed.");
}
```

---

### **6.3. Restrict Protocols**

- **Permit Only HTTP and HTTPS**: Block dangerous protocols such as `file://`, `ftp://`, or `gopher://`.

**Example**:

```csharp
if (validatedUri.Scheme != Uri.UriSchemeHttp && validatedUri.Scheme != Uri.UriSchemeHttps)
{
    throw new SecurityException("Only HTTP and HTTPS protocols are allowed.");
}
```

---

### **6.4. Avoid Dynamic URL Construction**

- **Use Fixed Endpoints**: When possible, avoid constructing URLs dynamically from user input; instead, use predefined endpoints and parameters.
- **Concatenate with Caution**: If concatenation is necessary, ensure that only safe parameters are appended.

**Example**:

```csharp
string baseUrl = "https://api.example.com/data?query=";
string userInput = Request["uri"];
if (!IsValidQuery(userInput))
{
    throw new ArgumentException("Invalid query parameter.");
}
Uri fullUri = new Uri(baseUrl + userInput);
```

---

### **6.5. Monitor and Log Suspicious Activity**

- **Audit Requests**: Log any network requests that use user-supplied URLs and monitor for patterns that indicate abuse.
- **Set Timeouts**: Configure connection and read timeouts to prevent long-running requests from impacting server performance.

**Example**:

```csharp
WebRequest request = WebRequest.Create(validatedUri);
request.Timeout = 5000; // 5 seconds timeout
```
